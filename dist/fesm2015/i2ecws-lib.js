import { InjectionToken, Injectable, Optional, Inject, NgModule, SkipSelf } from '@angular/core';
import { HttpHeaders, HttpClient, HttpUrlEncodingCodec, HttpParams } from '@angular/common/http';

const BASE_PATH = new InjectionToken('basePath');
const COLLECTION_FORMATS = {
    'csv': ',',
    'tsv': '   ',
    'ssv': ' ',
    'pipes': '|'
};

class Configuration {
    constructor(configurationParameters = {}) {
        this.apiKeys = configurationParameters.apiKeys;
        this.username = configurationParameters.username;
        this.password = configurationParameters.password;
        this.accessToken = configurationParameters.accessToken;
        this.basePath = configurationParameters.basePath;
        this.withCredentials = configurationParameters.withCredentials;
    }
    /**
     * Select the correct content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param contentTypes - the array of content types that are available for selection
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderContentType(contentTypes) {
        if (contentTypes.length == 0) {
            return undefined;
        }
        let type = contentTypes.find(x => this.isJsonMime(x));
        if (type === undefined) {
            return contentTypes[0];
        }
        return type;
    }
    /**
     * Select the correct accept content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param accepts - the array of content types that are available for selection.
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderAccept(accepts) {
        if (accepts.length == 0) {
            return undefined;
        }
        let type = accepts.find(x => this.isJsonMime(x));
        if (type === undefined) {
            return accepts[0];
        }
        return type;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class ActivitiesCodeControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getActivitiesCodesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/activities-code/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ActivitiesCodeControllerService.decorators = [
    { type: Injectable }
];
ActivitiesCodeControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class ApiQueueEntityService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    apiQueueApiServicesUsingDELETE(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueueApiServicesUsingDELETE.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        return this.httpClient.delete(`${this.basePath}/apiQueues/${encodeURIComponent(String(id))}/apiServices`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    apiQueueApiServicesUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueueApiServicesUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/hal+json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/apiQueues/${encodeURIComponent(String(id))}/apiServices`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    apiQueueApiServicesUsingPATCH(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling apiQueueApiServicesUsingPATCH.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueueApiServicesUsingPATCH.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.patch(`${this.basePath}/apiQueues/${encodeURIComponent(String(id))}/apiServices`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    apiQueueApiServicesUsingPOST(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling apiQueueApiServicesUsingPOST.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueueApiServicesUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/apiQueues/${encodeURIComponent(String(id))}/apiServices`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    apiQueueApiServicesUsingPUT(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling apiQueueApiServicesUsingPUT.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueueApiServicesUsingPUT.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.put(`${this.basePath}/apiQueues/${encodeURIComponent(String(id))}/apiServices`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ApiQueueEntityService.decorators = [
    { type: Injectable }
];
ApiQueueEntityService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
* CustomHttpUrlEncodingCodec
* Fix plus sign (+) not encoding, so sent as blank space
* See: https://github.com/angular/angular/issues/11058#issuecomment-247367318
*/
class CustomHttpUrlEncodingCodec extends HttpUrlEncodingCodec {
    encodeKey(k) {
        k = super.encodeKey(k);
        return k.replace(/\+/gi, '%2B');
    }
    encodeValue(v) {
        v = super.encodeValue(v);
        return v.replace(/\+/gi, '%2B');
    }
}

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class AppNavigationTControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getNavLinksUsingGET(roles, observe = 'body', reportProgress = false) {
        if (roles === null || roles === undefined) {
            throw new Error('Required parameter roles was null or undefined when calling getNavLinksUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (roles) {
            roles.forEach((element) => {
                queryParameters = queryParameters.append('roles', element);
            });
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/nav-links/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
AppNavigationTControllerService.decorators = [
    { type: Injectable }
];
AppNavigationTControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class AppNavigationTEntityService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    appNavigationTGwbLinksTUsingDELETE(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling appNavigationTGwbLinksTUsingDELETE.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        return this.httpClient.delete(`${this.basePath}/appNavigationTs/${encodeURIComponent(String(id))}/gwbLinksT`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    appNavigationTGwbLinksTUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling appNavigationTGwbLinksTUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/hal+json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/appNavigationTs/${encodeURIComponent(String(id))}/gwbLinksT`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    appNavigationTGwbLinksTUsingPATCH(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling appNavigationTGwbLinksTUsingPATCH.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling appNavigationTGwbLinksTUsingPATCH.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.patch(`${this.basePath}/appNavigationTs/${encodeURIComponent(String(id))}/gwbLinksT`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    appNavigationTGwbLinksTUsingPOST(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling appNavigationTGwbLinksTUsingPOST.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling appNavigationTGwbLinksTUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/appNavigationTs/${encodeURIComponent(String(id))}/gwbLinksT`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    appNavigationTGwbLinksTUsingPUT(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling appNavigationTGwbLinksTUsingPUT.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling appNavigationTGwbLinksTUsingPUT.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.put(`${this.basePath}/appNavigationTs/${encodeURIComponent(String(id))}/gwbLinksT`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
AppNavigationTEntityService.decorators = [
    { type: Injectable }
];
AppNavigationTEntityService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class AraControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getUnmatchedArasUsingGET(ncab, orderBy, observe = 'body', reportProgress = false) {
        if (ncab === null || ncab === undefined) {
            throw new Error('Required parameter ncab was null or undefined when calling getUnmatchedArasUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ara-match/${encodeURIComponent(String(ncab))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
AraControllerService.decorators = [
    { type: Injectable }
];
AraControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class AraReasonsControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    activateOrDeactivateAraReasonUsingPATCH(id, paramsHolder, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling activateOrDeactivateAraReasonUsingPATCH.');
        }
        if (paramsHolder === null || paramsHolder === undefined) {
            throw new Error('Required parameter paramsHolder was null or undefined when calling activateOrDeactivateAraReasonUsingPATCH.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.patch(`${this.basePath}/api/v1/ara-reasons/${encodeURIComponent(String(id))}`, paramsHolder, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAraReasonsHistoryUsingGET(code, observe = 'body', reportProgress = false) {
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAraReasonsHistoryUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ara-reasons-history/${encodeURIComponent(String(code))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAraReasonsPrecedencesUsingGET(available, include, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (available !== undefined && available !== null) {
            queryParameters = queryParameters.set('available', available);
        }
        if (include !== undefined && include !== null) {
            queryParameters = queryParameters.set('include', include);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ara-reasons-precedences`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAraReasonsUsingGET(activeFlag, orderBy, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeFlag !== undefined && activeFlag !== null) {
            queryParameters = queryParameters.set('activeFlag', activeFlag);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ara-reasons`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAraReasonsUsingGET1(code, activeFlag, observe = 'body', reportProgress = false) {
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAraReasonsUsingGET1.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeFlag !== undefined && activeFlag !== null) {
            queryParameters = queryParameters.set('activeFlag', activeFlag);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ara-reasons/${encodeURIComponent(String(code))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getEraAraReasonsUsingGET(activeFlag, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeFlag !== undefined && activeFlag !== null) {
            queryParameters = queryParameters.set('activeFlag', activeFlag);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/era-ara-reasons`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getEraAraReasonsUsingGET1(code, activeFlag, observe = 'body', reportProgress = false) {
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getEraAraReasonsUsingGET1.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeFlag !== undefined && activeFlag !== null) {
            queryParameters = queryParameters.set('activeFlag', activeFlag);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/era-ara-reasons/${encodeURIComponent(String(code))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveAraReasonUsingPOST(araReasonsDto, observe = 'body', reportProgress = false) {
        if (araReasonsDto === null || araReasonsDto === undefined) {
            throw new Error('Required parameter araReasonsDto was null or undefined when calling saveAraReasonUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/ara-reasons`, araReasonsDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateAraReasonUsingPUT(araReasonsDto, observe = 'body', reportProgress = false) {
        if (araReasonsDto === null || araReasonsDto === undefined) {
            throw new Error('Required parameter araReasonsDto was null or undefined when calling updateAraReasonUsingPUT.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.put(`${this.basePath}/api/v1/ara-reasons`, araReasonsDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
AraReasonsControllerService.decorators = [
    { type: Injectable }
];
AraReasonsControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class BoardsControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    findBoardByDateUsingGET(month, year, observe = 'body', reportProgress = false) {
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling findBoardByDateUsingGET.');
        }
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling findBoardByDateUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/boards/${encodeURIComponent(String(year))}/${encodeURIComponent(String(month))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getBoardsUsingGET(meetingDate, orderBy, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (meetingDate !== undefined && meetingDate !== null) {
            queryParameters = queryParameters.set('meetingDate', meetingDate);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/boards`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getBodDatesListUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ncabs`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCurrentWorkingBoardUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/boards/current-working-board`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDefaultNcabDateUsingGET(date, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (date !== undefined && date !== null) {
            queryParameters = queryParameters.set('date', date.toISOString());
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/boards/default-ncab-date`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveBoardUsingPOST(boardsDto, observe = 'body', reportProgress = false) {
        if (boardsDto === null || boardsDto === undefined) {
            throw new Error('Required parameter boardsDto was null or undefined when calling saveBoardUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/boards`, boardsDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateBoardUsingPUT(boardsDto, observe = 'body', reportProgress = false) {
        if (boardsDto === null || boardsDto === undefined) {
            throw new Error('Required parameter boardsDto was null or undefined when calling updateBoardUsingPUT.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.put(`${this.basePath}/api/v1/boards`, boardsDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateMeetingDateUsingPATCH(meetingDate, month, year, observe = 'body', reportProgress = false) {
        if (meetingDate === null || meetingDate === undefined) {
            throw new Error('Required parameter meetingDate was null or undefined when calling updateMeetingDateUsingPATCH.');
        }
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling updateMeetingDateUsingPATCH.');
        }
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling updateMeetingDateUsingPATCH.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (meetingDate !== undefined && meetingDate !== null) {
            queryParameters = queryParameters.set('meetingDate', meetingDate);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.patch(`${this.basePath}/api/v1/boards/${encodeURIComponent(String(year))}/${encodeURIComponent(String(month))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
BoardsControllerService.decorators = [
    { type: Injectable }
];
BoardsControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class CancerActivityControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    deactivateCaUsingPATCH(caCode, userId, observe = 'body', reportProgress = false) {
        if (caCode === null || caCode === undefined) {
            throw new Error('Required parameter caCode was null or undefined when calling deactivateCaUsingPATCH.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deactivateCaUsingPATCH.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (caCode !== undefined && caCode !== null) {
            queryParameters = queryParameters.set('caCode', caCode);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.patch(`${this.basePath}/api/v1/cas/`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getActiveReferralCaAssignRulesUsingGET(active, ignore, observe = 'body', reportProgress = false) {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getActiveReferralCaAssignRulesUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (ignore !== undefined && ignore !== null) {
            queryParameters = queryParameters.set('ignore', ignore);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-ca-assign-rules/${encodeURIComponent(String(active))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAllActiveCaListUsingGET(activeFlag, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeFlag !== undefined && activeFlag !== null) {
            queryParameters = queryParameters.set('activeFlag', activeFlag);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cas/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCaAssignmentRulesHistoryUsingGET(caCode, observe = 'body', reportProgress = false) {
        if (caCode === null || caCode === undefined) {
            throw new Error('Required parameter caCode was null or undefined when calling getCaAssignmentRulesHistoryUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ca-assignment-rules-history/${encodeURIComponent(String(caCode))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCaByPDActiveGrantPortfolioUsingGET(npeId, observe = 'body', reportProgress = false) {
        if (npeId === null || npeId === undefined) {
            throw new Error('Required parameter npeId was null or undefined when calling getCaByPDActiveGrantPortfolioUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/get-cas-by-pd-active-grant-portfolio/${encodeURIComponent(String(npeId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCaListBasedOnMechCodeUsingGET(mechCode, observe = 'body', reportProgress = false) {
        if (mechCode === null || mechCode === undefined) {
            throw new Error('Required parameter mechCode was null or undefined when calling getCaListBasedOnMechCodeUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (mechCode !== undefined && mechCode !== null) {
            queryParameters = queryParameters.set('mechCode', mechCode);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cas-mech-codes/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCaListBasedOnRfaUsingGET(rfaPa, observe = 'body', reportProgress = false) {
        if (rfaPa === null || rfaPa === undefined) {
            throw new Error('Required parameter rfaPa was null or undefined when calling getCaListBasedOnRfaUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (rfaPa !== undefined && rfaPa !== null) {
            queryParameters = queryParameters.set('rfaPa', rfaPa);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cas-rfa/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCaXferPortfolioUsingGET(pdId, observe = 'body', reportProgress = false) {
        if (pdId === null || pdId === undefined) {
            throw new Error('Required parameter pdId was null or undefined when calling getCaXferPortfolioUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cas-xfer/${encodeURIComponent(String(pdId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCancerActivityPocsUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cas/pocs`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCasForPdUsingGET(pdId, monitorFlag, observe = 'body', reportProgress = false) {
        if (pdId === null || pdId === undefined) {
            throw new Error('Required parameter pdId was null or undefined when calling getCasForPdUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (monitorFlag !== undefined && monitorFlag !== null) {
            queryParameters = queryParameters.set('monitorFlag', monitorFlag);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cas/${encodeURIComponent(String(pdId))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCasForPortfolioUsingGET(npeId, monitorFlag, observe = 'body', reportProgress = false) {
        if (npeId === null || npeId === undefined) {
            throw new Error('Required parameter npeId was null or undefined when calling getCasForPortfolioUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (monitorFlag !== undefined && monitorFlag !== null) {
            queryParameters = queryParameters.set('monitorFlag', monitorFlag);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cas-portfolio/${encodeURIComponent(String(npeId))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getNciOrgListUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/nci-org-list/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPersonDetailsUsingGET(orgId, observe = 'body', reportProgress = false) {
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling getPersonDetailsUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/i2e-person-details/${encodeURIComponent(String(orgId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReferralActivityCodesListUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-activity-codes/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getRfaPaNoticeByNoticeNumberUsingGET(noticeNumber, observe = 'body', reportProgress = false) {
        if (noticeNumber === null || noticeNumber === undefined) {
            throw new Error('Required parameter noticeNumber was null or undefined when calling getRfaPaNoticeByNoticeNumberUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/rfa-pa-notices/${encodeURIComponent(String(noticeNumber))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getRfaPaNoticesListUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/rfa-pa-notices/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveCancerActivityUsingPUT(addNew, caCode, caDesc, caOfcDiv, caPoc, userId, observe = 'body', reportProgress = false) {
        if (addNew === null || addNew === undefined) {
            throw new Error('Required parameter addNew was null or undefined when calling saveCancerActivityUsingPUT.');
        }
        if (caCode === null || caCode === undefined) {
            throw new Error('Required parameter caCode was null or undefined when calling saveCancerActivityUsingPUT.');
        }
        if (caDesc === null || caDesc === undefined) {
            throw new Error('Required parameter caDesc was null or undefined when calling saveCancerActivityUsingPUT.');
        }
        if (caOfcDiv === null || caOfcDiv === undefined) {
            throw new Error('Required parameter caOfcDiv was null or undefined when calling saveCancerActivityUsingPUT.');
        }
        if (caPoc === null || caPoc === undefined) {
            throw new Error('Required parameter caPoc was null or undefined when calling saveCancerActivityUsingPUT.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling saveCancerActivityUsingPUT.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (addNew !== undefined && addNew !== null) {
            queryParameters = queryParameters.set('addNew', addNew);
        }
        if (caCode !== undefined && caCode !== null) {
            queryParameters = queryParameters.set('caCode', caCode);
        }
        if (caDesc !== undefined && caDesc !== null) {
            queryParameters = queryParameters.set('caDesc', caDesc);
        }
        if (caOfcDiv !== undefined && caOfcDiv !== null) {
            queryParameters = queryParameters.set('caOfcDiv', caOfcDiv);
        }
        if (caPoc !== undefined && caPoc !== null) {
            queryParameters = queryParameters.set('caPoc', caPoc);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.put(`${this.basePath}/api/v1/cas/`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveMechCaAssignmentUsingPOST(mechCode, userId, assignedCas, observe = 'body', reportProgress = false) {
        if (mechCode === null || mechCode === undefined) {
            throw new Error('Required parameter mechCode was null or undefined when calling saveMechCaAssignmentUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling saveMechCaAssignmentUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (assignedCas) {
            assignedCas.forEach((element) => {
                queryParameters = queryParameters.append('assignedCas[]', element);
            });
        }
        if (mechCode !== undefined && mechCode !== null) {
            queryParameters = queryParameters.set('mechCode', mechCode);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/mech-ca-assignment/`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveRfaPaAssignmentUsingPOST(rfaPa, userId, assignedCas, observe = 'body', reportProgress = false) {
        if (rfaPa === null || rfaPa === undefined) {
            throw new Error('Required parameter rfaPa was null or undefined when calling saveRfaPaAssignmentUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling saveRfaPaAssignmentUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (assignedCas) {
            assignedCas.forEach((element) => {
                queryParameters = queryParameters.append('assignedCas[]', element);
            });
        }
        if (rfaPa !== undefined && rfaPa !== null) {
            queryParameters = queryParameters.set('rfaPa', rfaPa);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/rfa-pa-assignment/`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
CancerActivityControllerService.decorators = [
    { type: Injectable }
];
CancerActivityControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class CancerActivityRolesControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    gatAllCancerActivityRolesUsingGET(orderBy, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cancer-activity-roles/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCancerActivityRolesByNpeIdUsingGET(npeId, orderBy, observe = 'body', reportProgress = false) {
        if (npeId === null || npeId === undefined) {
            throw new Error('Required parameter npeId was null or undefined when calling getCancerActivityRolesByNpeIdUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/cancer-activity-roles/${encodeURIComponent(String(npeId))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
CancerActivityRolesControllerService.decorators = [
    { type: Injectable }
];
CancerActivityRolesControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class CgRefCodControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getRemoveCaInterestReasonsUsingGET(domain, orderBy, observe = 'body', reportProgress = false) {
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getRemoveCaInterestReasonsUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-reasons/${encodeURIComponent(String(domain))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
CgRefCodControllerService.decorators = [
    { type: Injectable }
];
CgRefCodControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class EmControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    helloUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/em/api/v1/hello-em/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
EmControllerService.decorators = [
    { type: Injectable }
];
EmControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class ExportControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    exportAraMatchReportUsingGET(ncab, requestParams, orderBy, observe = 'body', reportProgress = false) {
        if (ncab === null || ncab === undefined) {
            throw new Error('Required parameter ncab was null or undefined when calling exportAraMatchReportUsingGET.');
        }
        if (requestParams === null || requestParams === undefined) {
            throw new Error('Required parameter requestParams was null or undefined when calling exportAraMatchReportUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (requestParams !== undefined && requestParams !== null) {
            queryParameters = queryParameters.set('requestParams', requestParams);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/export/ara-match/${encodeURIComponent(String(ncab))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    exportCancerActivitiesUsingGET(active, requestParams, orderBy, observe = 'body', reportProgress = false) {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling exportCancerActivitiesUsingGET.');
        }
        if (requestParams === null || requestParams === undefined) {
            throw new Error('Required parameter requestParams was null or undefined when calling exportCancerActivitiesUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (requestParams !== undefined && requestParams !== null) {
            queryParameters = queryParameters.set('requestParams', requestParams);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/export/cas/${encodeURIComponent(String(active))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    exportCancerActivitiesUsingGET1(active, requestParams, orderBy, observe = 'body', reportProgress = false) {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling exportCancerActivitiesUsingGET1.');
        }
        if (requestParams === null || requestParams === undefined) {
            throw new Error('Required parameter requestParams was null or undefined when calling exportCancerActivitiesUsingGET1.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (requestParams !== undefined && requestParams !== null) {
            queryParameters = queryParameters.set('requestParams', requestParams);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/export/${encodeURIComponent(String(active))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCancerActivityPocsUsingGET1(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/export/cas/pocs`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getTransferRolePocsUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/export/xfer/pocs`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ExportControllerService.decorators = [
    { type: Injectable }
];
ExportControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class GwbLinksControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getLinksUsingGET(names, orderBy, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (names) {
            names.forEach((element) => {
                queryParameters = queryParameters.append('names', element);
            });
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/gwb-links`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
GwbLinksControllerService.decorators = [
    { type: Injectable }
];
GwbLinksControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class I2eUserActiveRolesControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getUsersByRoleCodeUsingGET(roleCode, observe = 'body', reportProgress = false) {
        if (roleCode === null || roleCode === undefined) {
            throw new Error('Required parameter roleCode was null or undefined when calling getUsersByRoleCodeUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/i2eusers-by-rolecode/${encodeURIComponent(String(roleCode))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
I2eUserActiveRolesControllerService.decorators = [
    { type: Injectable }
];
I2eUserActiveRolesControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class IcDataControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    appdFundinggsAssignUsingPOST(applId, directcostAmt, indirectcostAmt, phsOrgCode, totalPeriodAmt, transType, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling appdFundinggsAssignUsingPOST.');
        }
        if (directcostAmt === null || directcostAmt === undefined) {
            throw new Error('Required parameter directcostAmt was null or undefined when calling appdFundinggsAssignUsingPOST.');
        }
        if (indirectcostAmt === null || indirectcostAmt === undefined) {
            throw new Error('Required parameter indirectcostAmt was null or undefined when calling appdFundinggsAssignUsingPOST.');
        }
        if (phsOrgCode === null || phsOrgCode === undefined) {
            throw new Error('Required parameter phsOrgCode was null or undefined when calling appdFundinggsAssignUsingPOST.');
        }
        if (totalPeriodAmt === null || totalPeriodAmt === undefined) {
            throw new Error('Required parameter totalPeriodAmt was null or undefined when calling appdFundinggsAssignUsingPOST.');
        }
        if (transType === null || transType === undefined) {
            throw new Error('Required parameter transType was null or undefined when calling appdFundinggsAssignUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (directcostAmt !== undefined && directcostAmt !== null) {
            queryParameters = queryParameters.set('directcostAmt', directcostAmt);
        }
        if (indirectcostAmt !== undefined && indirectcostAmt !== null) {
            queryParameters = queryParameters.set('indirectcostAmt', indirectcostAmt);
        }
        if (phsOrgCode !== undefined && phsOrgCode !== null) {
            queryParameters = queryParameters.set('phsOrgCode', phsOrgCode);
        }
        if (totalPeriodAmt !== undefined && totalPeriodAmt !== null) {
            queryParameters = queryParameters.set('totalPeriodAmt', totalPeriodAmt);
        }
        if (transType !== undefined && transType !== null) {
            queryParameters = queryParameters.set('transType', transType);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/appd-fundings/assign/${encodeURIComponent(String(applId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    awdFundingsAssignUsingPOST(applId, phsOrgCode, transType, newCan, newPcc, oldCan, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling awdFundingsAssignUsingPOST.');
        }
        if (phsOrgCode === null || phsOrgCode === undefined) {
            throw new Error('Required parameter phsOrgCode was null or undefined when calling awdFundingsAssignUsingPOST.');
        }
        if (transType === null || transType === undefined) {
            throw new Error('Required parameter transType was null or undefined when calling awdFundingsAssignUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (newCan !== undefined && newCan !== null) {
            queryParameters = queryParameters.set('newCan', newCan);
        }
        if (newPcc !== undefined && newPcc !== null) {
            queryParameters = queryParameters.set('newPcc', newPcc);
        }
        if (oldCan !== undefined && oldCan !== null) {
            queryParameters = queryParameters.set('oldCan', oldCan);
        }
        if (phsOrgCode !== undefined && phsOrgCode !== null) {
            queryParameters = queryParameters.set('phsOrgCode', phsOrgCode);
        }
        if (transType !== undefined && transType !== null) {
            queryParameters = queryParameters.set('transType', transType);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/awd-fundings/assign/${encodeURIComponent(String(applId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    fedPersonInvolvementAssignUsingPOST(applId, personId, phsOrgCode, roleTypeCode, transactionType, versionCode, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling fedPersonInvolvementAssignUsingPOST.');
        }
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling fedPersonInvolvementAssignUsingPOST.');
        }
        if (phsOrgCode === null || phsOrgCode === undefined) {
            throw new Error('Required parameter phsOrgCode was null or undefined when calling fedPersonInvolvementAssignUsingPOST.');
        }
        if (roleTypeCode === null || roleTypeCode === undefined) {
            throw new Error('Required parameter roleTypeCode was null or undefined when calling fedPersonInvolvementAssignUsingPOST.');
        }
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling fedPersonInvolvementAssignUsingPOST.');
        }
        if (versionCode === null || versionCode === undefined) {
            throw new Error('Required parameter versionCode was null or undefined when calling fedPersonInvolvementAssignUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (personId !== undefined && personId !== null) {
            queryParameters = queryParameters.set('personId', personId);
        }
        if (phsOrgCode !== undefined && phsOrgCode !== null) {
            queryParameters = queryParameters.set('phsOrgCode', phsOrgCode);
        }
        if (roleTypeCode !== undefined && roleTypeCode !== null) {
            queryParameters = queryParameters.set('roleTypeCode', roleTypeCode);
        }
        if (transactionType !== undefined && transactionType !== null) {
            queryParameters = queryParameters.set('transactionType', transactionType);
        }
        if (versionCode !== undefined && versionCode !== null) {
            queryParameters = queryParameters.set('versionCode', versionCode);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/fed-person-involvement/assign/${encodeURIComponent(String(applId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    icPccAssignMergeUsingPOST(applId, phsOrgCode, transactionType, newPccCode, oldPccCode, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling icPccAssignMergeUsingPOST.');
        }
        if (phsOrgCode === null || phsOrgCode === undefined) {
            throw new Error('Required parameter phsOrgCode was null or undefined when calling icPccAssignMergeUsingPOST.');
        }
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling icPccAssignMergeUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (newPccCode !== undefined && newPccCode !== null) {
            queryParameters = queryParameters.set('newPccCode', newPccCode);
        }
        if (oldPccCode !== undefined && oldPccCode !== null) {
            queryParameters = queryParameters.set('oldPccCode', oldPccCode);
        }
        if (phsOrgCode !== undefined && phsOrgCode !== null) {
            queryParameters = queryParameters.set('phsOrgCode', phsOrgCode);
        }
        if (transactionType !== undefined && transactionType !== null) {
            queryParameters = queryParameters.set('transactionType', transactionType);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/ic-pcc/assign-merge/${encodeURIComponent(String(applId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    icPccAssignUsingPOST(applId, phsOrgCode, transactionType, newPccCode, oldPccCode, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling icPccAssignUsingPOST.');
        }
        if (phsOrgCode === null || phsOrgCode === undefined) {
            throw new Error('Required parameter phsOrgCode was null or undefined when calling icPccAssignUsingPOST.');
        }
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling icPccAssignUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (newPccCode !== undefined && newPccCode !== null) {
            queryParameters = queryParameters.set('newPccCode', newPccCode);
        }
        if (oldPccCode !== undefined && oldPccCode !== null) {
            queryParameters = queryParameters.set('oldPccCode', oldPccCode);
        }
        if (phsOrgCode !== undefined && phsOrgCode !== null) {
            queryParameters = queryParameters.set('phsOrgCode', phsOrgCode);
        }
        if (transactionType !== undefined && transactionType !== null) {
            queryParameters = queryParameters.set('transactionType', transactionType);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/ic-pcc/assign/${encodeURIComponent(String(applId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    mainPccAssignUsingPOST(applId, overWriteFlag, phsOrgCode, progClassCode, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling mainPccAssignUsingPOST.');
        }
        if (overWriteFlag === null || overWriteFlag === undefined) {
            throw new Error('Required parameter overWriteFlag was null or undefined when calling mainPccAssignUsingPOST.');
        }
        if (phsOrgCode === null || phsOrgCode === undefined) {
            throw new Error('Required parameter phsOrgCode was null or undefined when calling mainPccAssignUsingPOST.');
        }
        if (progClassCode === null || progClassCode === undefined) {
            throw new Error('Required parameter progClassCode was null or undefined when calling mainPccAssignUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (overWriteFlag !== undefined && overWriteFlag !== null) {
            queryParameters = queryParameters.set('overWriteFlag', overWriteFlag);
        }
        if (phsOrgCode !== undefined && phsOrgCode !== null) {
            queryParameters = queryParameters.set('phsOrgCode', phsOrgCode);
        }
        if (progClassCode !== undefined && progClassCode !== null) {
            queryParameters = queryParameters.set('progClassCode', progClassCode);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/main-pcc/assign/${encodeURIComponent(String(applId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    pccDetailsUsingPOST(applId, phsOrgCode, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling pccDetailsUsingPOST.');
        }
        if (phsOrgCode === null || phsOrgCode === undefined) {
            throw new Error('Required parameter phsOrgCode was null or undefined when calling pccDetailsUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (phsOrgCode !== undefined && phsOrgCode !== null) {
            queryParameters = queryParameters.set('phsOrgCode', phsOrgCode);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/pcc-details/${encodeURIComponent(String(applId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
IcDataControllerService.decorators = [
    { type: Injectable }
];
IcDataControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class JasperReportControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    generateJasperReportUsingGET(EXPORT_FMT, id, name, promptexPReportId, promptexPSessionId, type, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (EXPORT_FMT !== undefined && EXPORT_FMT !== null) {
            queryParameters = queryParameters.set('EXPORT_FMT', EXPORT_FMT);
        }
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', id);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', name);
        }
        if (promptexPReportId !== undefined && promptexPReportId !== null) {
            queryParameters = queryParameters.set('promptex-pReportId', promptexPReportId);
        }
        if (promptexPSessionId !== undefined && promptexPSessionId !== null) {
            queryParameters = queryParameters.set('promptex-pSessionId', promptexPSessionId);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('type', type);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/pdf',
            'application/vnd.ms-excel'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/generate-jasper-report`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    generateJasperReportUsingPOST(report, observe = 'body', reportProgress = false) {
        if (report === null || report === undefined) {
            throw new Error('Required parameter report was null or undefined when calling generateJasperReportUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/generate-jasper-report`, report, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    generatePaylistReportUsingGET(paylistId, reportName, type, observe = 'body', reportProgress = false) {
        if (paylistId === null || paylistId === undefined) {
            throw new Error('Required parameter paylistId was null or undefined when calling generatePaylistReportUsingGET.');
        }
        if (reportName === null || reportName === undefined) {
            throw new Error('Required parameter reportName was null or undefined when calling generatePaylistReportUsingGET.');
        }
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling generatePaylistReportUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/pdf',
            'application/vnd.ms-excel'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/generate-paylist-report/${encodeURIComponent(String(paylistId))}/${encodeURIComponent(String(reportName))}/${encodeURIComponent(String(type))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
JasperReportControllerService.decorators = [
    { type: Injectable }
];
JasperReportControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class LookupsControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getDocAndCayCodesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/lookups/cayCode-doc`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getNciDocsUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/lookups/nci-doc`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPiInstitutesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/lookups/pi-institutes`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
LookupsControllerService.decorators = [
    { type: Injectable }
];
LookupsControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class NciReferralGrantsControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    exportGrantSearchResultsUsingGET(remainingParams, activeSegments, applIds, applStatusGroupCode, araMatchStatus, cancerActivities, composedGrantNumber, dualCas, formerGrantNumber, fyFrom, fyTo, grantIc, grantMech, grantSerial, grantSuffix, grantsWitCa, grantType, grantYear, groupCode, includeDeleted, includeOrphans, institution, irgCode, irgFlexCode, myCancerActivities, ncabFrom, ncabTo, npnId, orderBy, pdAssignmentSearch, pdId, piName, referralOfficer, referralStatus, rfaPaNumber, role, roNpnId, selectFrom, sraDesignatorCode, sraFlexCode, wBSearch, observe = 'body', reportProgress = false) {
        if (remainingParams === null || remainingParams === undefined) {
            throw new Error('Required parameter remainingParams was null or undefined when calling exportGrantSearchResultsUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeSegments !== undefined && activeSegments !== null) {
            queryParameters = queryParameters.set('activeSegments', activeSegments);
        }
        if (applIds) {
            applIds.forEach((element) => {
                queryParameters = queryParameters.append('applIds', element);
            });
        }
        if (applStatusGroupCode) {
            applStatusGroupCode.forEach((element) => {
                queryParameters = queryParameters.append('applStatusGroupCode', element);
            });
        }
        if (araMatchStatus) {
            araMatchStatus.forEach((element) => {
                queryParameters = queryParameters.append('araMatchStatus', element);
            });
        }
        if (cancerActivities) {
            cancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('cancerActivities', element);
            });
        }
        if (composedGrantNumber !== undefined && composedGrantNumber !== null) {
            queryParameters = queryParameters.set('composedGrantNumber', composedGrantNumber);
        }
        if (dualCas !== undefined && dualCas !== null) {
            queryParameters = queryParameters.set('dualCas', dualCas);
        }
        if (formerGrantNumber !== undefined && formerGrantNumber !== null) {
            queryParameters = queryParameters.set('formerGrantNumber', formerGrantNumber);
        }
        if (fyFrom !== undefined && fyFrom !== null) {
            queryParameters = queryParameters.set('fyFrom', fyFrom);
        }
        if (fyTo !== undefined && fyTo !== null) {
            queryParameters = queryParameters.set('fyTo', fyTo);
        }
        if (grantIc !== undefined && grantIc !== null) {
            queryParameters = queryParameters.set('grantIc', grantIc);
        }
        if (grantMech !== undefined && grantMech !== null) {
            queryParameters = queryParameters.set('grantMech', grantMech);
        }
        if (grantSerial !== undefined && grantSerial !== null) {
            queryParameters = queryParameters.set('grantSerial', grantSerial);
        }
        if (grantSuffix !== undefined && grantSuffix !== null) {
            queryParameters = queryParameters.set('grantSuffix', grantSuffix);
        }
        if (grantsWitCa !== undefined && grantsWitCa !== null) {
            queryParameters = queryParameters.set('grantsWitCa', grantsWitCa);
        }
        if (grantType !== undefined && grantType !== null) {
            queryParameters = queryParameters.set('grantType', grantType);
        }
        if (grantYear !== undefined && grantYear !== null) {
            queryParameters = queryParameters.set('grantYear', grantYear);
        }
        if (groupCode !== undefined && groupCode !== null) {
            queryParameters = queryParameters.set('groupCode', groupCode);
        }
        if (includeDeleted !== undefined && includeDeleted !== null) {
            queryParameters = queryParameters.set('includeDeleted', includeDeleted);
        }
        if (includeOrphans !== undefined && includeOrphans !== null) {
            queryParameters = queryParameters.set('includeOrphans', includeOrphans);
        }
        if (institution !== undefined && institution !== null) {
            queryParameters = queryParameters.set('institution', institution);
        }
        if (irgCode !== undefined && irgCode !== null) {
            queryParameters = queryParameters.set('irgCode', irgCode);
        }
        if (irgFlexCode !== undefined && irgFlexCode !== null) {
            queryParameters = queryParameters.set('irgFlexCode', irgFlexCode);
        }
        if (myCancerActivities) {
            myCancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('myCancerActivities', element);
            });
        }
        if (ncabFrom !== undefined && ncabFrom !== null) {
            queryParameters = queryParameters.set('ncabFrom', ncabFrom);
        }
        if (ncabTo !== undefined && ncabTo !== null) {
            queryParameters = queryParameters.set('ncabTo', ncabTo);
        }
        if (npnId !== undefined && npnId !== null) {
            queryParameters = queryParameters.set('npnId', npnId);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (pdAssignmentSearch !== undefined && pdAssignmentSearch !== null) {
            queryParameters = queryParameters.set('pdAssignmentSearch', pdAssignmentSearch);
        }
        if (pdId !== undefined && pdId !== null) {
            queryParameters = queryParameters.set('pdId', pdId);
        }
        if (piName !== undefined && piName !== null) {
            queryParameters = queryParameters.set('piName', piName);
        }
        if (referralOfficer !== undefined && referralOfficer !== null) {
            queryParameters = queryParameters.set('referralOfficer', referralOfficer);
        }
        if (referralStatus) {
            referralStatus.forEach((element) => {
                queryParameters = queryParameters.append('referralStatus', element);
            });
        }
        if (remainingParams !== undefined && remainingParams !== null) {
            queryParameters = queryParameters.set('remainingParams', remainingParams);
        }
        if (rfaPaNumber) {
            rfaPaNumber.forEach((element) => {
                queryParameters = queryParameters.append('rfaPaNumber', element);
            });
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', role);
        }
        if (roNpnId !== undefined && roNpnId !== null) {
            queryParameters = queryParameters.set('roNpnId', roNpnId);
        }
        if (selectFrom !== undefined && selectFrom !== null) {
            queryParameters = queryParameters.set('selectFrom', selectFrom);
        }
        if (sraDesignatorCode !== undefined && sraDesignatorCode !== null) {
            queryParameters = queryParameters.set('sraDesignatorCode', sraDesignatorCode);
        }
        if (sraFlexCode !== undefined && sraFlexCode !== null) {
            queryParameters = queryParameters.set('sraFlexCode', sraFlexCode);
        }
        if (wBSearch !== undefined && wBSearch !== null) {
            queryParameters = queryParameters.set('WBSearch', wBSearch);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/export/transfer-grants`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    exportSearchResultsUsingGET(remainingParams, activeSegments, applIds, applStatusGroupCode, araMatchStatus, cancerActivities, composedGrantNumber, dualCas, formerGrantNumber, fyFrom, fyTo, grantIc, grantMech, grantSerial, grantSuffix, grantsWitCa, grantType, grantYear, groupCode, includeDeleted, includeOrphans, institution, irgCode, irgFlexCode, myCancerActivities, ncabFrom, ncabTo, npnId, orderBy, pdAssignmentSearch, pdId, piName, referralOfficer, referralStatus, rfaPaNumber, role, roNpnId, selectFrom, sraDesignatorCode, sraFlexCode, wBSearch, observe = 'body', reportProgress = false) {
        if (remainingParams === null || remainingParams === undefined) {
            throw new Error('Required parameter remainingParams was null or undefined when calling exportSearchResultsUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeSegments !== undefined && activeSegments !== null) {
            queryParameters = queryParameters.set('activeSegments', activeSegments);
        }
        if (applIds) {
            applIds.forEach((element) => {
                queryParameters = queryParameters.append('applIds', element);
            });
        }
        if (applStatusGroupCode) {
            applStatusGroupCode.forEach((element) => {
                queryParameters = queryParameters.append('applStatusGroupCode', element);
            });
        }
        if (araMatchStatus) {
            araMatchStatus.forEach((element) => {
                queryParameters = queryParameters.append('araMatchStatus', element);
            });
        }
        if (cancerActivities) {
            cancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('cancerActivities', element);
            });
        }
        if (composedGrantNumber !== undefined && composedGrantNumber !== null) {
            queryParameters = queryParameters.set('composedGrantNumber', composedGrantNumber);
        }
        if (dualCas !== undefined && dualCas !== null) {
            queryParameters = queryParameters.set('dualCas', dualCas);
        }
        if (formerGrantNumber !== undefined && formerGrantNumber !== null) {
            queryParameters = queryParameters.set('formerGrantNumber', formerGrantNumber);
        }
        if (fyFrom !== undefined && fyFrom !== null) {
            queryParameters = queryParameters.set('fyFrom', fyFrom);
        }
        if (fyTo !== undefined && fyTo !== null) {
            queryParameters = queryParameters.set('fyTo', fyTo);
        }
        if (grantIc !== undefined && grantIc !== null) {
            queryParameters = queryParameters.set('grantIc', grantIc);
        }
        if (grantMech !== undefined && grantMech !== null) {
            queryParameters = queryParameters.set('grantMech', grantMech);
        }
        if (grantSerial !== undefined && grantSerial !== null) {
            queryParameters = queryParameters.set('grantSerial', grantSerial);
        }
        if (grantSuffix !== undefined && grantSuffix !== null) {
            queryParameters = queryParameters.set('grantSuffix', grantSuffix);
        }
        if (grantsWitCa !== undefined && grantsWitCa !== null) {
            queryParameters = queryParameters.set('grantsWitCa', grantsWitCa);
        }
        if (grantType !== undefined && grantType !== null) {
            queryParameters = queryParameters.set('grantType', grantType);
        }
        if (grantYear !== undefined && grantYear !== null) {
            queryParameters = queryParameters.set('grantYear', grantYear);
        }
        if (groupCode !== undefined && groupCode !== null) {
            queryParameters = queryParameters.set('groupCode', groupCode);
        }
        if (includeDeleted !== undefined && includeDeleted !== null) {
            queryParameters = queryParameters.set('includeDeleted', includeDeleted);
        }
        if (includeOrphans !== undefined && includeOrphans !== null) {
            queryParameters = queryParameters.set('includeOrphans', includeOrphans);
        }
        if (institution !== undefined && institution !== null) {
            queryParameters = queryParameters.set('institution', institution);
        }
        if (irgCode !== undefined && irgCode !== null) {
            queryParameters = queryParameters.set('irgCode', irgCode);
        }
        if (irgFlexCode !== undefined && irgFlexCode !== null) {
            queryParameters = queryParameters.set('irgFlexCode', irgFlexCode);
        }
        if (myCancerActivities) {
            myCancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('myCancerActivities', element);
            });
        }
        if (ncabFrom !== undefined && ncabFrom !== null) {
            queryParameters = queryParameters.set('ncabFrom', ncabFrom);
        }
        if (ncabTo !== undefined && ncabTo !== null) {
            queryParameters = queryParameters.set('ncabTo', ncabTo);
        }
        if (npnId !== undefined && npnId !== null) {
            queryParameters = queryParameters.set('npnId', npnId);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (pdAssignmentSearch !== undefined && pdAssignmentSearch !== null) {
            queryParameters = queryParameters.set('pdAssignmentSearch', pdAssignmentSearch);
        }
        if (pdId !== undefined && pdId !== null) {
            queryParameters = queryParameters.set('pdId', pdId);
        }
        if (piName !== undefined && piName !== null) {
            queryParameters = queryParameters.set('piName', piName);
        }
        if (referralOfficer !== undefined && referralOfficer !== null) {
            queryParameters = queryParameters.set('referralOfficer', referralOfficer);
        }
        if (referralStatus) {
            referralStatus.forEach((element) => {
                queryParameters = queryParameters.append('referralStatus', element);
            });
        }
        if (remainingParams !== undefined && remainingParams !== null) {
            queryParameters = queryParameters.set('remainingParams', remainingParams);
        }
        if (rfaPaNumber) {
            rfaPaNumber.forEach((element) => {
                queryParameters = queryParameters.append('rfaPaNumber', element);
            });
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', role);
        }
        if (roNpnId !== undefined && roNpnId !== null) {
            queryParameters = queryParameters.set('roNpnId', roNpnId);
        }
        if (selectFrom !== undefined && selectFrom !== null) {
            queryParameters = queryParameters.set('selectFrom', selectFrom);
        }
        if (sraDesignatorCode !== undefined && sraDesignatorCode !== null) {
            queryParameters = queryParameters.set('sraDesignatorCode', sraDesignatorCode);
        }
        if (sraFlexCode !== undefined && sraFlexCode !== null) {
            queryParameters = queryParameters.set('sraFlexCode', sraFlexCode);
        }
        if (wBSearch !== undefined && wBSearch !== null) {
            queryParameters = queryParameters.set('WBSearch', wBSearch);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/export/referral-grants`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    exportSearchResultsUsingPOST(remainingParams, activeSegments, applIds, applStatusGroupCode, araMatchStatus, cancerActivities, composedGrantNumber, dualCas, formerGrantNumber, fyFrom, fyTo, grantIc, grantMech, grantSerial, grantSuffix, grantsWitCa, grantType, grantYear, groupCode, includeDeleted, includeOrphans, institution, irgCode, irgFlexCode, myCancerActivities, ncabFrom, ncabTo, npnId, orderBy, pdAssignmentSearch, pdId, piName, referralOfficer, referralStatus, rfaPaNumber, role, roNpnId, selectFrom, sraDesignatorCode, sraFlexCode, wBSearch, observe = 'body', reportProgress = false) {
        if (remainingParams === null || remainingParams === undefined) {
            throw new Error('Required parameter remainingParams was null or undefined when calling exportSearchResultsUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeSegments !== undefined && activeSegments !== null) {
            queryParameters = queryParameters.set('activeSegments', activeSegments);
        }
        if (applIds) {
            applIds.forEach((element) => {
                queryParameters = queryParameters.append('applIds', element);
            });
        }
        if (applStatusGroupCode) {
            applStatusGroupCode.forEach((element) => {
                queryParameters = queryParameters.append('applStatusGroupCode', element);
            });
        }
        if (araMatchStatus) {
            araMatchStatus.forEach((element) => {
                queryParameters = queryParameters.append('araMatchStatus', element);
            });
        }
        if (cancerActivities) {
            cancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('cancerActivities', element);
            });
        }
        if (composedGrantNumber !== undefined && composedGrantNumber !== null) {
            queryParameters = queryParameters.set('composedGrantNumber', composedGrantNumber);
        }
        if (dualCas !== undefined && dualCas !== null) {
            queryParameters = queryParameters.set('dualCas', dualCas);
        }
        if (formerGrantNumber !== undefined && formerGrantNumber !== null) {
            queryParameters = queryParameters.set('formerGrantNumber', formerGrantNumber);
        }
        if (fyFrom !== undefined && fyFrom !== null) {
            queryParameters = queryParameters.set('fyFrom', fyFrom);
        }
        if (fyTo !== undefined && fyTo !== null) {
            queryParameters = queryParameters.set('fyTo', fyTo);
        }
        if (grantIc !== undefined && grantIc !== null) {
            queryParameters = queryParameters.set('grantIc', grantIc);
        }
        if (grantMech !== undefined && grantMech !== null) {
            queryParameters = queryParameters.set('grantMech', grantMech);
        }
        if (grantSerial !== undefined && grantSerial !== null) {
            queryParameters = queryParameters.set('grantSerial', grantSerial);
        }
        if (grantSuffix !== undefined && grantSuffix !== null) {
            queryParameters = queryParameters.set('grantSuffix', grantSuffix);
        }
        if (grantsWitCa !== undefined && grantsWitCa !== null) {
            queryParameters = queryParameters.set('grantsWitCa', grantsWitCa);
        }
        if (grantType !== undefined && grantType !== null) {
            queryParameters = queryParameters.set('grantType', grantType);
        }
        if (grantYear !== undefined && grantYear !== null) {
            queryParameters = queryParameters.set('grantYear', grantYear);
        }
        if (groupCode !== undefined && groupCode !== null) {
            queryParameters = queryParameters.set('groupCode', groupCode);
        }
        if (includeDeleted !== undefined && includeDeleted !== null) {
            queryParameters = queryParameters.set('includeDeleted', includeDeleted);
        }
        if (includeOrphans !== undefined && includeOrphans !== null) {
            queryParameters = queryParameters.set('includeOrphans', includeOrphans);
        }
        if (institution !== undefined && institution !== null) {
            queryParameters = queryParameters.set('institution', institution);
        }
        if (irgCode !== undefined && irgCode !== null) {
            queryParameters = queryParameters.set('irgCode', irgCode);
        }
        if (irgFlexCode !== undefined && irgFlexCode !== null) {
            queryParameters = queryParameters.set('irgFlexCode', irgFlexCode);
        }
        if (myCancerActivities) {
            myCancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('myCancerActivities', element);
            });
        }
        if (ncabFrom !== undefined && ncabFrom !== null) {
            queryParameters = queryParameters.set('ncabFrom', ncabFrom);
        }
        if (ncabTo !== undefined && ncabTo !== null) {
            queryParameters = queryParameters.set('ncabTo', ncabTo);
        }
        if (npnId !== undefined && npnId !== null) {
            queryParameters = queryParameters.set('npnId', npnId);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (pdAssignmentSearch !== undefined && pdAssignmentSearch !== null) {
            queryParameters = queryParameters.set('pdAssignmentSearch', pdAssignmentSearch);
        }
        if (pdId !== undefined && pdId !== null) {
            queryParameters = queryParameters.set('pdId', pdId);
        }
        if (piName !== undefined && piName !== null) {
            queryParameters = queryParameters.set('piName', piName);
        }
        if (referralOfficer !== undefined && referralOfficer !== null) {
            queryParameters = queryParameters.set('referralOfficer', referralOfficer);
        }
        if (referralStatus) {
            referralStatus.forEach((element) => {
                queryParameters = queryParameters.append('referralStatus', element);
            });
        }
        if (remainingParams !== undefined && remainingParams !== null) {
            queryParameters = queryParameters.set('remainingParams', remainingParams);
        }
        if (rfaPaNumber) {
            rfaPaNumber.forEach((element) => {
                queryParameters = queryParameters.append('rfaPaNumber', element);
            });
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', role);
        }
        if (roNpnId !== undefined && roNpnId !== null) {
            queryParameters = queryParameters.set('roNpnId', roNpnId);
        }
        if (selectFrom !== undefined && selectFrom !== null) {
            queryParameters = queryParameters.set('selectFrom', selectFrom);
        }
        if (sraDesignatorCode !== undefined && sraDesignatorCode !== null) {
            queryParameters = queryParameters.set('sraDesignatorCode', sraDesignatorCode);
        }
        if (sraFlexCode !== undefined && sraFlexCode !== null) {
            queryParameters = queryParameters.set('sraFlexCode', sraFlexCode);
        }
        if (wBSearch !== undefined && wBSearch !== null) {
            queryParameters = queryParameters.set('WBSearch', wBSearch);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/export/referral-grants`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    findWithdrawnGrantsUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-grants/withdrawn`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getSuggestedCayCodesUsingGET(applId, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling getSuggestedCayCodesUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-grants/suggested-cay-codes/${encodeURIComponent(String(applId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchGrantsForPDAssignmentUsingGET(remainingParams, activeSegments, applId, applIds, applStatusGroupCode, araMatchStatus, cancerActivities, composedGrantNumber, dualCas, formerGrantNumber, fyFrom, fyTo, grantIc, grantMech, grantSerial, grantSuffix, grantsWitCa, grantType, grantYear, groupCode, includeDeleted, includeOrphans, institution, irgCode, irgFlexCode, myCancerActivities, ncabFrom, ncabTo, npnId, orderBy, pdAssignmentSearch, pdId, piName, referralOfficer, referralStatus, rfaPaNumber, role, roNpnId, selectFrom, sraDesignatorCode, sraFlexCode, wBSearch, observe = 'body', reportProgress = false) {
        if (remainingParams === null || remainingParams === undefined) {
            throw new Error('Required parameter remainingParams was null or undefined when calling searchGrantsForPDAssignmentUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeSegments !== undefined && activeSegments !== null) {
            queryParameters = queryParameters.set('activeSegments', activeSegments);
        }
        if (applId) {
            applId.forEach((element) => {
                queryParameters = queryParameters.append('applId', element);
            });
        }
        if (applIds) {
            applIds.forEach((element) => {
                queryParameters = queryParameters.append('applIds', element);
            });
        }
        if (applStatusGroupCode) {
            applStatusGroupCode.forEach((element) => {
                queryParameters = queryParameters.append('applStatusGroupCode', element);
            });
        }
        if (araMatchStatus) {
            araMatchStatus.forEach((element) => {
                queryParameters = queryParameters.append('araMatchStatus', element);
            });
        }
        if (cancerActivities) {
            cancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('cancerActivities', element);
            });
        }
        if (composedGrantNumber !== undefined && composedGrantNumber !== null) {
            queryParameters = queryParameters.set('composedGrantNumber', composedGrantNumber);
        }
        if (dualCas !== undefined && dualCas !== null) {
            queryParameters = queryParameters.set('dualCas', dualCas);
        }
        if (formerGrantNumber !== undefined && formerGrantNumber !== null) {
            queryParameters = queryParameters.set('formerGrantNumber', formerGrantNumber);
        }
        if (fyFrom !== undefined && fyFrom !== null) {
            queryParameters = queryParameters.set('fyFrom', fyFrom);
        }
        if (fyTo !== undefined && fyTo !== null) {
            queryParameters = queryParameters.set('fyTo', fyTo);
        }
        if (grantIc !== undefined && grantIc !== null) {
            queryParameters = queryParameters.set('grantIc', grantIc);
        }
        if (grantMech !== undefined && grantMech !== null) {
            queryParameters = queryParameters.set('grantMech', grantMech);
        }
        if (grantSerial !== undefined && grantSerial !== null) {
            queryParameters = queryParameters.set('grantSerial', grantSerial);
        }
        if (grantSuffix !== undefined && grantSuffix !== null) {
            queryParameters = queryParameters.set('grantSuffix', grantSuffix);
        }
        if (grantsWitCa !== undefined && grantsWitCa !== null) {
            queryParameters = queryParameters.set('grantsWitCa', grantsWitCa);
        }
        if (grantType !== undefined && grantType !== null) {
            queryParameters = queryParameters.set('grantType', grantType);
        }
        if (grantYear !== undefined && grantYear !== null) {
            queryParameters = queryParameters.set('grantYear', grantYear);
        }
        if (groupCode !== undefined && groupCode !== null) {
            queryParameters = queryParameters.set('groupCode', groupCode);
        }
        if (includeDeleted !== undefined && includeDeleted !== null) {
            queryParameters = queryParameters.set('includeDeleted', includeDeleted);
        }
        if (includeOrphans !== undefined && includeOrphans !== null) {
            queryParameters = queryParameters.set('includeOrphans', includeOrphans);
        }
        if (institution !== undefined && institution !== null) {
            queryParameters = queryParameters.set('institution', institution);
        }
        if (irgCode !== undefined && irgCode !== null) {
            queryParameters = queryParameters.set('irgCode', irgCode);
        }
        if (irgFlexCode !== undefined && irgFlexCode !== null) {
            queryParameters = queryParameters.set('irgFlexCode', irgFlexCode);
        }
        if (myCancerActivities) {
            myCancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('myCancerActivities', element);
            });
        }
        if (ncabFrom !== undefined && ncabFrom !== null) {
            queryParameters = queryParameters.set('ncabFrom', ncabFrom);
        }
        if (ncabTo !== undefined && ncabTo !== null) {
            queryParameters = queryParameters.set('ncabTo', ncabTo);
        }
        if (npnId !== undefined && npnId !== null) {
            queryParameters = queryParameters.set('npnId', npnId);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (pdAssignmentSearch !== undefined && pdAssignmentSearch !== null) {
            queryParameters = queryParameters.set('pdAssignmentSearch', pdAssignmentSearch);
        }
        if (pdId !== undefined && pdId !== null) {
            queryParameters = queryParameters.set('pdId', pdId);
        }
        if (piName !== undefined && piName !== null) {
            queryParameters = queryParameters.set('piName', piName);
        }
        if (referralOfficer !== undefined && referralOfficer !== null) {
            queryParameters = queryParameters.set('referralOfficer', referralOfficer);
        }
        if (referralStatus) {
            referralStatus.forEach((element) => {
                queryParameters = queryParameters.append('referralStatus', element);
            });
        }
        if (remainingParams !== undefined && remainingParams !== null) {
            queryParameters = queryParameters.set('remainingParams', remainingParams);
        }
        if (rfaPaNumber) {
            rfaPaNumber.forEach((element) => {
                queryParameters = queryParameters.append('rfaPaNumber', element);
            });
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', role);
        }
        if (roNpnId !== undefined && roNpnId !== null) {
            queryParameters = queryParameters.set('roNpnId', roNpnId);
        }
        if (selectFrom !== undefined && selectFrom !== null) {
            queryParameters = queryParameters.set('selectFrom', selectFrom);
        }
        if (sraDesignatorCode !== undefined && sraDesignatorCode !== null) {
            queryParameters = queryParameters.set('sraDesignatorCode', sraDesignatorCode);
        }
        if (sraFlexCode !== undefined && sraFlexCode !== null) {
            queryParameters = queryParameters.set('sraFlexCode', sraFlexCode);
        }
        if (wBSearch !== undefined && wBSearch !== null) {
            queryParameters = queryParameters.set('WBSearch', wBSearch);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/pd-assignment/search`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchReferralGrantsUsingGET(remainingParams, activeSegments, applIds, applStatusGroupCode, araMatchStatus, cancerActivities, composedGrantNumber, dualCas, formerGrantNumber, fyFrom, fyTo, grantIc, grantMech, grantSerial, grantSuffix, grantsWitCa, grantType, grantYear, groupCode, includeDeleted, includeOrphans, institution, irgCode, irgFlexCode, myCancerActivities, ncabFrom, ncabTo, npnId, orderBy, pdAssignmentSearch, pdId, piName, referralOfficer, referralStatus, rfaPaNumber, role, roNpnId, selectFrom, sraDesignatorCode, sraFlexCode, wBSearch, observe = 'body', reportProgress = false) {
        if (remainingParams === null || remainingParams === undefined) {
            throw new Error('Required parameter remainingParams was null or undefined when calling searchReferralGrantsUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeSegments !== undefined && activeSegments !== null) {
            queryParameters = queryParameters.set('activeSegments', activeSegments);
        }
        if (applIds) {
            applIds.forEach((element) => {
                queryParameters = queryParameters.append('applIds', element);
            });
        }
        if (applStatusGroupCode) {
            applStatusGroupCode.forEach((element) => {
                queryParameters = queryParameters.append('applStatusGroupCode', element);
            });
        }
        if (araMatchStatus) {
            araMatchStatus.forEach((element) => {
                queryParameters = queryParameters.append('araMatchStatus', element);
            });
        }
        if (cancerActivities) {
            cancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('cancerActivities', element);
            });
        }
        if (composedGrantNumber !== undefined && composedGrantNumber !== null) {
            queryParameters = queryParameters.set('composedGrantNumber', composedGrantNumber);
        }
        if (dualCas !== undefined && dualCas !== null) {
            queryParameters = queryParameters.set('dualCas', dualCas);
        }
        if (formerGrantNumber !== undefined && formerGrantNumber !== null) {
            queryParameters = queryParameters.set('formerGrantNumber', formerGrantNumber);
        }
        if (fyFrom !== undefined && fyFrom !== null) {
            queryParameters = queryParameters.set('fyFrom', fyFrom);
        }
        if (fyTo !== undefined && fyTo !== null) {
            queryParameters = queryParameters.set('fyTo', fyTo);
        }
        if (grantIc !== undefined && grantIc !== null) {
            queryParameters = queryParameters.set('grantIc', grantIc);
        }
        if (grantMech !== undefined && grantMech !== null) {
            queryParameters = queryParameters.set('grantMech', grantMech);
        }
        if (grantSerial !== undefined && grantSerial !== null) {
            queryParameters = queryParameters.set('grantSerial', grantSerial);
        }
        if (grantSuffix !== undefined && grantSuffix !== null) {
            queryParameters = queryParameters.set('grantSuffix', grantSuffix);
        }
        if (grantsWitCa !== undefined && grantsWitCa !== null) {
            queryParameters = queryParameters.set('grantsWitCa', grantsWitCa);
        }
        if (grantType !== undefined && grantType !== null) {
            queryParameters = queryParameters.set('grantType', grantType);
        }
        if (grantYear !== undefined && grantYear !== null) {
            queryParameters = queryParameters.set('grantYear', grantYear);
        }
        if (groupCode !== undefined && groupCode !== null) {
            queryParameters = queryParameters.set('groupCode', groupCode);
        }
        if (includeDeleted !== undefined && includeDeleted !== null) {
            queryParameters = queryParameters.set('includeDeleted', includeDeleted);
        }
        if (includeOrphans !== undefined && includeOrphans !== null) {
            queryParameters = queryParameters.set('includeOrphans', includeOrphans);
        }
        if (institution !== undefined && institution !== null) {
            queryParameters = queryParameters.set('institution', institution);
        }
        if (irgCode !== undefined && irgCode !== null) {
            queryParameters = queryParameters.set('irgCode', irgCode);
        }
        if (irgFlexCode !== undefined && irgFlexCode !== null) {
            queryParameters = queryParameters.set('irgFlexCode', irgFlexCode);
        }
        if (myCancerActivities) {
            myCancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('myCancerActivities', element);
            });
        }
        if (ncabFrom !== undefined && ncabFrom !== null) {
            queryParameters = queryParameters.set('ncabFrom', ncabFrom);
        }
        if (ncabTo !== undefined && ncabTo !== null) {
            queryParameters = queryParameters.set('ncabTo', ncabTo);
        }
        if (npnId !== undefined && npnId !== null) {
            queryParameters = queryParameters.set('npnId', npnId);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (pdAssignmentSearch !== undefined && pdAssignmentSearch !== null) {
            queryParameters = queryParameters.set('pdAssignmentSearch', pdAssignmentSearch);
        }
        if (pdId !== undefined && pdId !== null) {
            queryParameters = queryParameters.set('pdId', pdId);
        }
        if (piName !== undefined && piName !== null) {
            queryParameters = queryParameters.set('piName', piName);
        }
        if (referralOfficer !== undefined && referralOfficer !== null) {
            queryParameters = queryParameters.set('referralOfficer', referralOfficer);
        }
        if (referralStatus) {
            referralStatus.forEach((element) => {
                queryParameters = queryParameters.append('referralStatus', element);
            });
        }
        if (remainingParams !== undefined && remainingParams !== null) {
            queryParameters = queryParameters.set('remainingParams', remainingParams);
        }
        if (rfaPaNumber) {
            rfaPaNumber.forEach((element) => {
                queryParameters = queryParameters.append('rfaPaNumber', element);
            });
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', role);
        }
        if (roNpnId !== undefined && roNpnId !== null) {
            queryParameters = queryParameters.set('roNpnId', roNpnId);
        }
        if (selectFrom !== undefined && selectFrom !== null) {
            queryParameters = queryParameters.set('selectFrom', selectFrom);
        }
        if (sraDesignatorCode !== undefined && sraDesignatorCode !== null) {
            queryParameters = queryParameters.set('sraDesignatorCode', sraDesignatorCode);
        }
        if (sraFlexCode !== undefined && sraFlexCode !== null) {
            queryParameters = queryParameters.set('sraFlexCode', sraFlexCode);
        }
        if (wBSearch !== undefined && wBSearch !== null) {
            queryParameters = queryParameters.set('WBSearch', wBSearch);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-grants/search`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchReferralGrantsUsingPOST(remainingParams, activeSegments, applIds, applStatusGroupCode, araMatchStatus, cancerActivities, composedGrantNumber, dualCas, formerGrantNumber, fyFrom, fyTo, grantIc, grantMech, grantSerial, grantSuffix, grantsWitCa, grantType, grantYear, groupCode, includeDeleted, includeOrphans, institution, irgCode, irgFlexCode, myCancerActivities, ncabFrom, ncabTo, npnId, orderBy, pdAssignmentSearch, pdId, piName, referralOfficer, referralStatus, rfaPaNumber, role, roNpnId, selectFrom, sraDesignatorCode, sraFlexCode, wBSearch, observe = 'body', reportProgress = false) {
        if (remainingParams === null || remainingParams === undefined) {
            throw new Error('Required parameter remainingParams was null or undefined when calling searchReferralGrantsUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeSegments !== undefined && activeSegments !== null) {
            queryParameters = queryParameters.set('activeSegments', activeSegments);
        }
        if (applIds) {
            applIds.forEach((element) => {
                queryParameters = queryParameters.append('applIds', element);
            });
        }
        if (applStatusGroupCode) {
            applStatusGroupCode.forEach((element) => {
                queryParameters = queryParameters.append('applStatusGroupCode', element);
            });
        }
        if (araMatchStatus) {
            araMatchStatus.forEach((element) => {
                queryParameters = queryParameters.append('araMatchStatus', element);
            });
        }
        if (cancerActivities) {
            cancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('cancerActivities', element);
            });
        }
        if (composedGrantNumber !== undefined && composedGrantNumber !== null) {
            queryParameters = queryParameters.set('composedGrantNumber', composedGrantNumber);
        }
        if (dualCas !== undefined && dualCas !== null) {
            queryParameters = queryParameters.set('dualCas', dualCas);
        }
        if (formerGrantNumber !== undefined && formerGrantNumber !== null) {
            queryParameters = queryParameters.set('formerGrantNumber', formerGrantNumber);
        }
        if (fyFrom !== undefined && fyFrom !== null) {
            queryParameters = queryParameters.set('fyFrom', fyFrom);
        }
        if (fyTo !== undefined && fyTo !== null) {
            queryParameters = queryParameters.set('fyTo', fyTo);
        }
        if (grantIc !== undefined && grantIc !== null) {
            queryParameters = queryParameters.set('grantIc', grantIc);
        }
        if (grantMech !== undefined && grantMech !== null) {
            queryParameters = queryParameters.set('grantMech', grantMech);
        }
        if (grantSerial !== undefined && grantSerial !== null) {
            queryParameters = queryParameters.set('grantSerial', grantSerial);
        }
        if (grantSuffix !== undefined && grantSuffix !== null) {
            queryParameters = queryParameters.set('grantSuffix', grantSuffix);
        }
        if (grantsWitCa !== undefined && grantsWitCa !== null) {
            queryParameters = queryParameters.set('grantsWitCa', grantsWitCa);
        }
        if (grantType !== undefined && grantType !== null) {
            queryParameters = queryParameters.set('grantType', grantType);
        }
        if (grantYear !== undefined && grantYear !== null) {
            queryParameters = queryParameters.set('grantYear', grantYear);
        }
        if (groupCode !== undefined && groupCode !== null) {
            queryParameters = queryParameters.set('groupCode', groupCode);
        }
        if (includeDeleted !== undefined && includeDeleted !== null) {
            queryParameters = queryParameters.set('includeDeleted', includeDeleted);
        }
        if (includeOrphans !== undefined && includeOrphans !== null) {
            queryParameters = queryParameters.set('includeOrphans', includeOrphans);
        }
        if (institution !== undefined && institution !== null) {
            queryParameters = queryParameters.set('institution', institution);
        }
        if (irgCode !== undefined && irgCode !== null) {
            queryParameters = queryParameters.set('irgCode', irgCode);
        }
        if (irgFlexCode !== undefined && irgFlexCode !== null) {
            queryParameters = queryParameters.set('irgFlexCode', irgFlexCode);
        }
        if (myCancerActivities) {
            myCancerActivities.forEach((element) => {
                queryParameters = queryParameters.append('myCancerActivities', element);
            });
        }
        if (ncabFrom !== undefined && ncabFrom !== null) {
            queryParameters = queryParameters.set('ncabFrom', ncabFrom);
        }
        if (ncabTo !== undefined && ncabTo !== null) {
            queryParameters = queryParameters.set('ncabTo', ncabTo);
        }
        if (npnId !== undefined && npnId !== null) {
            queryParameters = queryParameters.set('npnId', npnId);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (pdAssignmentSearch !== undefined && pdAssignmentSearch !== null) {
            queryParameters = queryParameters.set('pdAssignmentSearch', pdAssignmentSearch);
        }
        if (pdId !== undefined && pdId !== null) {
            queryParameters = queryParameters.set('pdId', pdId);
        }
        if (piName !== undefined && piName !== null) {
            queryParameters = queryParameters.set('piName', piName);
        }
        if (referralOfficer !== undefined && referralOfficer !== null) {
            queryParameters = queryParameters.set('referralOfficer', referralOfficer);
        }
        if (referralStatus) {
            referralStatus.forEach((element) => {
                queryParameters = queryParameters.append('referralStatus', element);
            });
        }
        if (remainingParams !== undefined && remainingParams !== null) {
            queryParameters = queryParameters.set('remainingParams', remainingParams);
        }
        if (rfaPaNumber) {
            rfaPaNumber.forEach((element) => {
                queryParameters = queryParameters.append('rfaPaNumber', element);
            });
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', role);
        }
        if (roNpnId !== undefined && roNpnId !== null) {
            queryParameters = queryParameters.set('roNpnId', roNpnId);
        }
        if (selectFrom !== undefined && selectFrom !== null) {
            queryParameters = queryParameters.set('selectFrom', selectFrom);
        }
        if (sraDesignatorCode !== undefined && sraDesignatorCode !== null) {
            queryParameters = queryParameters.set('sraDesignatorCode', sraDesignatorCode);
        }
        if (sraFlexCode !== undefined && sraFlexCode !== null) {
            queryParameters = queryParameters.set('sraFlexCode', sraFlexCode);
        }
        if (wBSearch !== undefined && wBSearch !== null) {
            queryParameters = queryParameters.set('WBSearch', wBSearch);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/referral-grants/search`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchUsingGET(applId, cancerActivity, grantsWithoutInterest, mech, minDaysSinceReferral, ncabFromDate, ncabToDate, orderBy, pocNpnId, referralDateHigh, referralDateLow, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (applId) {
            applId.forEach((element) => {
                queryParameters = queryParameters.append('applId', element);
            });
        }
        if (cancerActivity !== undefined && cancerActivity !== null) {
            queryParameters = queryParameters.set('cancerActivity', cancerActivity);
        }
        if (grantsWithoutInterest !== undefined && grantsWithoutInterest !== null) {
            queryParameters = queryParameters.set('grantsWithoutInterest', grantsWithoutInterest);
        }
        if (mech !== undefined && mech !== null) {
            queryParameters = queryParameters.set('mech', mech);
        }
        if (minDaysSinceReferral !== undefined && minDaysSinceReferral !== null) {
            queryParameters = queryParameters.set('minDaysSinceReferral', minDaysSinceReferral);
        }
        if (ncabFromDate !== undefined && ncabFromDate !== null) {
            queryParameters = queryParameters.set('ncabFromDate', ncabFromDate);
        }
        if (ncabToDate !== undefined && ncabToDate !== null) {
            queryParameters = queryParameters.set('ncabToDate', ncabToDate);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        if (pocNpnId !== undefined && pocNpnId !== null) {
            queryParameters = queryParameters.set('pocNpnId', pocNpnId);
        }
        if (referralDateHigh !== undefined && referralDateHigh !== null) {
            queryParameters = queryParameters.set('referralDateHigh', referralDateHigh);
        }
        if (referralDateLow !== undefined && referralDateLow !== null) {
            queryParameters = queryParameters.set('referralDateLow', referralDateLow);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-grants`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
NciReferralGrantsControllerService.decorators = [
    { type: Injectable }
];
NciReferralGrantsControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PaylineCertificationsTEntityService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    paylineCertificationsTPaylineStatusesUsingDELETE(id, paylinestatusestId, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineCertificationsTPaylineStatusesUsingDELETE.');
        }
        if (paylinestatusestId === null || paylinestatusestId === undefined) {
            throw new Error('Required parameter paylinestatusestId was null or undefined when calling paylineCertificationsTPaylineStatusesUsingDELETE.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        return this.httpClient.delete(`${this.basePath}/paylineCertificationsTs/${encodeURIComponent(String(id))}/paylineStatuses/${encodeURIComponent(String(paylinestatusestId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineCertificationsTPaylineStatusesUsingDELETE1(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineCertificationsTPaylineStatusesUsingDELETE1.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        return this.httpClient.delete(`${this.basePath}/paylineCertificationsTs/${encodeURIComponent(String(id))}/paylineStatuses`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineCertificationsTPaylineStatusesUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineCertificationsTPaylineStatusesUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/hal+json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/paylineCertificationsTs/${encodeURIComponent(String(id))}/paylineStatuses`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineCertificationsTPaylineStatusesUsingGET1(id, paylinestatusestId, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineCertificationsTPaylineStatusesUsingGET1.');
        }
        if (paylinestatusestId === null || paylinestatusestId === undefined) {
            throw new Error('Required parameter paylinestatusestId was null or undefined when calling paylineCertificationsTPaylineStatusesUsingGET1.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/hal+json'
        ];
        return this.httpClient.get(`${this.basePath}/paylineCertificationsTs/${encodeURIComponent(String(id))}/paylineStatuses/${encodeURIComponent(String(paylinestatusestId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineCertificationsTPaylineStatusesUsingPATCH(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling paylineCertificationsTPaylineStatusesUsingPATCH.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineCertificationsTPaylineStatusesUsingPATCH.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.patch(`${this.basePath}/paylineCertificationsTs/${encodeURIComponent(String(id))}/paylineStatuses`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineCertificationsTPaylineStatusesUsingPOST(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling paylineCertificationsTPaylineStatusesUsingPOST.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineCertificationsTPaylineStatusesUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/paylineCertificationsTs/${encodeURIComponent(String(id))}/paylineStatuses`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineCertificationsTPaylineStatusesUsingPUT(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling paylineCertificationsTPaylineStatusesUsingPUT.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineCertificationsTPaylineStatusesUsingPUT.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.put(`${this.basePath}/paylineCertificationsTs/${encodeURIComponent(String(id))}/paylineStatuses`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PaylineCertificationsTEntityService.decorators = [
    { type: Injectable }
];
PaylineCertificationsTEntityService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PaylineControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    cancelPaylinesUsingPATCH(paylineId, userId, observe = 'body', reportProgress = false) {
        if (paylineId === null || paylineId === undefined) {
            throw new Error('Required parameter paylineId was null or undefined when calling cancelPaylinesUsingPATCH.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling cancelPaylinesUsingPATCH.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (paylineId !== undefined && paylineId !== null) {
            queryParameters = queryParameters.set('payline_id', paylineId);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.patch(`${this.basePath}/api/v1/paylines/`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    certifyPaylinesUsingPOST(paylinesDto, observe = 'body', reportProgress = false) {
        if (paylinesDto === null || paylinesDto === undefined) {
            throw new Error('Required parameter paylinesDto was null or undefined when calling certifyPaylinesUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/paylines/certify`, paylinesDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    findCertifiedPaylinesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/certified-paylines`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getFiscalYearUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/fiscal-years`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getNewPaylinesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/new-paylines`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getOEFIAPaylinesUsingGET(certifiedFlag, fy, isOefiaCertifier, userId, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (certifiedFlag !== undefined && certifiedFlag !== null) {
            queryParameters = queryParameters.set('certifiedFlag', certifiedFlag);
        }
        if (fy !== undefined && fy !== null) {
            queryParameters = queryParameters.set('fy', fy);
        }
        if (isOefiaCertifier !== undefined && isOefiaCertifier !== null) {
            queryParameters = queryParameters.set('isOefiaCertifier', isOefiaCertifier);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/oefia-paylines`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylineHistoryByIdUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaylineHistoryByIdUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylines/history/id/${encodeURIComponent(String(id))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylineHistoryUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaylineHistoryUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylines/${encodeURIComponent(String(id))}/history`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylinesByIdUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaylinesByIdUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/view-paylines/id/${encodeURIComponent(String(id))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylinesByParametersUsingGET(fy, activityCode, observe = 'body', reportProgress = false) {
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getPaylinesByParametersUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activityCode !== undefined && activityCode !== null) {
            queryParameters = queryParameters.set('activityCode', activityCode);
        }
        if (fy !== undefined && fy !== null) {
            queryParameters = queryParameters.set('fy', fy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylines/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylinesUsingGET(activityCode, fy, observe = 'body', reportProgress = false) {
        if (activityCode === null || activityCode === undefined) {
            throw new Error('Required parameter activityCode was null or undefined when calling getPaylinesUsingGET.');
        }
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getPaylinesUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylines/${encodeURIComponent(String(fy))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylinesUsingGET1(activityCode, fy, observe = 'body', reportProgress = false) {
        if (activityCode === null || activityCode === undefined) {
            throw new Error('Required parameter activityCode was null or undefined when calling getPaylinesUsingGET1.');
        }
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getPaylinesUsingGET1.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylines/${encodeURIComponent(String(fy))}/${encodeURIComponent(String(activityCode))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    unCertifyPaylinesUsingPOST(paylinesDto, observe = 'body', reportProgress = false) {
        if (paylinesDto === null || paylinesDto === undefined) {
            throw new Error('Required parameter paylinesDto was null or undefined when calling unCertifyPaylinesUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/paylines/un-certify`, paylinesDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PaylineControllerService.decorators = [
    { type: Injectable }
];
PaylineControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PaylineStatusesTEntityService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    paylineStatusesTStatusIdUsingDELETE(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineStatusesTStatusIdUsingDELETE.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        return this.httpClient.delete(`${this.basePath}/paylineStatusesTs/${encodeURIComponent(String(id))}/statusId`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineStatusesTStatusIdUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineStatusesTStatusIdUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/hal+json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/paylineStatusesTs/${encodeURIComponent(String(id))}/statusId`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineStatusesTStatusIdUsingPATCH(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling paylineStatusesTStatusIdUsingPATCH.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineStatusesTStatusIdUsingPATCH.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.patch(`${this.basePath}/paylineStatusesTs/${encodeURIComponent(String(id))}/statusId`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineStatusesTStatusIdUsingPOST(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling paylineStatusesTStatusIdUsingPOST.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineStatusesTStatusIdUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/paylineStatusesTs/${encodeURIComponent(String(id))}/statusId`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    paylineStatusesTStatusIdUsingPUT(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling paylineStatusesTStatusIdUsingPUT.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paylineStatusesTStatusIdUsingPUT.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.put(`${this.basePath}/paylineStatusesTs/${encodeURIComponent(String(id))}/statusId`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PaylineStatusesTEntityService.decorators = [
    { type: Injectable }
];
PaylineStatusesTEntityService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PaylistControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    certifyPaylistUsingPOST(paylistDto, observe = 'body', reportProgress = false) {
        if (paylistDto === null || paylistDto === undefined) {
            throw new Error('Required parameter paylistDto was null or undefined when calling certifyPaylistUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/paylists/certify-paylist`, paylistDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deletePaylistUsingDELETE(paylistId, userId, observe = 'body', reportProgress = false) {
        if (paylistId === null || paylistId === undefined) {
            throw new Error('Required parameter paylistId was null or undefined when calling deletePaylistUsingDELETE.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deletePaylistUsingDELETE.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (paylistId !== undefined && paylistId !== null) {
            queryParameters = queryParameters.set('paylistId', paylistId);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.delete(`${this.basePath}/api/v1/paylists/delete`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    findPaylistsUsingPOST(criteriaDto, observe = 'body', reportProgress = false) {
        if (criteriaDto === null || criteriaDto === undefined) {
            throw new Error('Required parameter criteriaDto was null or undefined when calling findPaylistsUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/paylists/find-paylists`, criteriaDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDeactivatedUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/deactivated-paylists`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylineHistoryByIdUsingGET1(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaylineHistoryByIdUsingGET1.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylists/history/id/${encodeURIComponent(String(id))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylistFiscalYearsUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-fiscal-years`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylistGrantsByIdUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaylistGrantsByIdUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-grants/id/${encodeURIComponent(String(id))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylistGrantsUsingGET(activityCode, fy, observe = 'body', reportProgress = false) {
        if (activityCode === null || activityCode === undefined) {
            throw new Error('Required parameter activityCode was null or undefined when calling getPaylistGrantsUsingGET.');
        }
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getPaylistGrantsUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-grants/${encodeURIComponent(String(fy))}/${encodeURIComponent(String(activityCode))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylistsUsingGET(fy, observe = 'body', reportProgress = false) {
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getPaylistsUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (fy !== undefined && fy !== null) {
            queryParameters = queryParameters.set('fy', fy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/view-paylists`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPendingGrantsUsingGET(fy, observe = 'body', reportProgress = false) {
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getPendingGrantsUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (fy !== undefined && fy !== null) {
            queryParameters = queryParameters.set('fy', fy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/pending-grants`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getUncertifiedUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/uncertified-paylists`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    savePaylistUsingPOST(paylistDto, observe = 'body', reportProgress = false) {
        if (paylistDto === null || paylistDto === undefined) {
            throw new Error('Required parameter paylistDto was null or undefined when calling savePaylistUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/paylists/save-paylist`, paylistDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PaylistControllerService.decorators = [
    { type: Injectable }
];
PaylistControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PaylistGrantsControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    findPaylistGrantsUsingPOST(criteriaDto, observe = 'body', reportProgress = false) {
        if (criteriaDto === null || criteriaDto === undefined) {
            throw new Error('Required parameter criteriaDto was null or undefined when calling findPaylistGrantsUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/paylist-grants/find-open`, criteriaDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getExceptionMappingUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-grants/exception-mapping`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    massGenPaylistEnabledUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-grants/mass-gen-enabled`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    massGeneratePaylistsUsingPOST(userId, observe = 'body', reportProgress = false) {
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling massGeneratePaylistsUsingPOST.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/paylist-grants/mass-gen-paylists`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    retrievePaylistGrantsByIdUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling retrievePaylistGrantsByIdUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-grants/retrieve/id/${encodeURIComponent(String(id))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchPaylinePaylistGrantsUsingPOST(criteriaDto, observe = 'body', reportProgress = false) {
        if (criteriaDto === null || criteriaDto === undefined) {
            throw new Error('Required parameter criteriaDto was null or undefined when calling searchPaylinePaylistGrantsUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/paylist-grants/search-ppg`, criteriaDto, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PaylistGrantsControllerService.decorators = [
    { type: Injectable }
];
PaylistGrantsControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PaylistUtilControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getBudgetMechanismsForFyUsingGET(fy, observe = 'body', reportProgress = false) {
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getBudgetMechanismsForFyUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-util/budget-mechanisms/${encodeURIComponent(String(fy))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCostCentersUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-util/cost-centers`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylistStatusesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-util/paylist-statuses`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPaylistTypesUsingGET(fy, observe = 'body', reportProgress = false) {
        if (fy === null || fy === undefined) {
            throw new Error('Required parameter fy was null or undefined when calling getPaylistTypesUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/paylist-util/paylist-types/${encodeURIComponent(String(fy))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PaylistUtilControllerService.decorators = [
    { type: Injectable }
];
PaylistUtilControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PdControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getPDListUsingGET(active, observe = 'body', reportProgress = false) {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getPDListUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/pd-list/${encodeURIComponent(String(active))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPDPortfoliosUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/pd-portfolios/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPdsByCayCodeUsingGET(ca, orderBy, observe = 'body', reportProgress = false) {
        if (ca === null || ca === undefined) {
            throw new Error('Required parameter ca was null or undefined when calling getPdsByCayCodeUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/pds/${encodeURIComponent(String(ca))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPdsByCayCodesUsingGET(cas, orderBy, observe = 'body', reportProgress = false) {
        if (cas === null || cas === undefined) {
            throw new Error('Required parameter cas was null or undefined when calling getPdsByCayCodesUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (cas) {
            cas.forEach((element) => {
                queryParameters = queryParameters.append('cas', element);
            });
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/pds/ca/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    isPdHasActiveGrantPortfolioUsingGET(npeId, observe = 'body', reportProgress = false) {
        if (npeId === null || npeId === undefined) {
            throw new Error('Required parameter npeId was null or undefined when calling isPdHasActiveGrantPortfolioUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/check-pd-has-active-grant-portfolio/${encodeURIComponent(String(npeId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PdControllerService.decorators = [
    { type: Injectable }
];
PdControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class PropertiesControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getPropertiesUsingGET(app, observe = 'body', reportProgress = false) {
        if (app === null || app === undefined) {
            throw new Error('Required parameter app was null or undefined when calling getPropertiesUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/properties/${encodeURIComponent(String(app))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPropertiesUsingGET1(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/properties/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPropertyUsingGET(app, propKey, defaultValue, observe = 'body', reportProgress = false) {
        if (app === null || app === undefined) {
            throw new Error('Required parameter app was null or undefined when calling getPropertyUsingGET.');
        }
        if (propKey === null || propKey === undefined) {
            throw new Error('Required parameter propKey was null or undefined when calling getPropertyUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (defaultValue !== undefined && defaultValue !== null) {
            queryParameters = queryParameters.set('defaultValue', defaultValue);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/properties/${encodeURIComponent(String(app))}/${encodeURIComponent(String(propKey))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
PropertiesControllerService.decorators = [
    { type: Injectable }
];
PropertiesControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class ReferralMessagesControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getMessagesForApplIdUsingGET(applId, orderBy, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling getMessagesForApplIdUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral/message/${encodeURIComponent(String(applId))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    readAllMessagesUsingPOST(applId, npnId, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling readAllMessagesUsingPOST.');
        }
        if (npnId === null || npnId === undefined) {
            throw new Error('Required parameter npnId was null or undefined when calling readAllMessagesUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/referral/message-read/${encodeURIComponent(String(applId))}/${encodeURIComponent(String(npnId))}`, null, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    readMessageUsingPOST(message, observe = 'body', reportProgress = false) {
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling readMessageUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/message-read`, message, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveMessageUsingPOST(message, observe = 'body', reportProgress = false) {
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling saveMessageUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/message`, message, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ReferralMessagesControllerService.decorators = [
    { type: Injectable }
];
ReferralMessagesControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class ReferralMessagesTEntityService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    referralMessagesTMessagesReadUsingDELETE(id, referralmessagesreadtId, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling referralMessagesTMessagesReadUsingDELETE.');
        }
        if (referralmessagesreadtId === null || referralmessagesreadtId === undefined) {
            throw new Error('Required parameter referralmessagesreadtId was null or undefined when calling referralMessagesTMessagesReadUsingDELETE.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        return this.httpClient.delete(`${this.basePath}/referralMessagesTs/${encodeURIComponent(String(id))}/messagesRead/${encodeURIComponent(String(referralmessagesreadtId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    referralMessagesTMessagesReadUsingDELETE1(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling referralMessagesTMessagesReadUsingDELETE1.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        return this.httpClient.delete(`${this.basePath}/referralMessagesTs/${encodeURIComponent(String(id))}/messagesRead`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    referralMessagesTMessagesReadUsingGET(id, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling referralMessagesTMessagesReadUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/hal+json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/referralMessagesTs/${encodeURIComponent(String(id))}/messagesRead`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    referralMessagesTMessagesReadUsingGET1(id, referralmessagesreadtId, observe = 'body', reportProgress = false) {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling referralMessagesTMessagesReadUsingGET1.');
        }
        if (referralmessagesreadtId === null || referralmessagesreadtId === undefined) {
            throw new Error('Required parameter referralmessagesreadtId was null or undefined when calling referralMessagesTMessagesReadUsingGET1.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/hal+json'
        ];
        return this.httpClient.get(`${this.basePath}/referralMessagesTs/${encodeURIComponent(String(id))}/messagesRead/${encodeURIComponent(String(referralmessagesreadtId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    referralMessagesTMessagesReadUsingPATCH(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling referralMessagesTMessagesReadUsingPATCH.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling referralMessagesTMessagesReadUsingPATCH.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.patch(`${this.basePath}/referralMessagesTs/${encodeURIComponent(String(id))}/messagesRead`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    referralMessagesTMessagesReadUsingPOST(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling referralMessagesTMessagesReadUsingPOST.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling referralMessagesTMessagesReadUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/referralMessagesTs/${encodeURIComponent(String(id))}/messagesRead`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    referralMessagesTMessagesReadUsingPUT(body, id, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling referralMessagesTMessagesReadUsingPUT.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling referralMessagesTMessagesReadUsingPUT.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            '*/*'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'text/uri-list',
            'application/x-spring-data-compact+json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.put(`${this.basePath}/referralMessagesTs/${encodeURIComponent(String(id))}/messagesRead`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ReferralMessagesTEntityService.decorators = [
    { type: Injectable }
];
ReferralMessagesTEntityService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class ReferralSearchCriteriaControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getAraMatchStatusesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ara-statuses/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getI2eStatusesUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/i2e-statuses`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReferralCloseReasonsUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-close-reasons`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReferralFromUsingGET(role, npnId, observe = 'body', reportProgress = false) {
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling getReferralFromUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (npnId !== undefined && npnId !== null) {
            queryParameters = queryParameters.set('npnId', npnId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-from/${encodeURIComponent(String(role))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReferralStatusesUsingGET(role, observe = 'body', reportProgress = false) {
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling getReferralStatusesUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-statuses/${encodeURIComponent(String(role))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ReferralSearchCriteriaControllerService.decorators = [
    { type: Injectable }
];
ReferralSearchCriteriaControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class ReferralWorkflowControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    acceptUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling acceptUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling acceptUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/accept/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    addCaInterestUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling addCaInterestUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addCaInterestUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/add-ca-interest/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    assignROUsingPOST(applToRos, userId, observe = 'body', reportProgress = false) {
        if (applToRos === null || applToRos === undefined) {
            throw new Error('Required parameter applToRos was null or undefined when calling assignROUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling assignROUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/assign-ro/${encodeURIComponent(String(userId))}`, applToRos, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    closeReferralUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling closeReferralUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling closeReferralUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/close-referral/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCurrentRefPssCodeUsingGET(applId, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling getCurrentRefPssCodeUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral/current-ref-pss-code/${encodeURIComponent(String(applId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPreviousPdCaUsingGET(applId, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling getPreviousPdCaUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral/previous-pd-ca/${encodeURIComponent(String(applId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReferralActionHistoryUsingGET(applId, orderBy, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling getReferralActionHistoryUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', orderBy);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral-action-history/${encodeURIComponent(String(applId))}`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReopenPssCodeUsingGET(applId, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling getReopenPssCodeUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral/reopen-pss-code/${encodeURIComponent(String(applId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReopenPssDescriptionUsingGET(applId, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling getReopenPssDescriptionUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral/reopen-pss-description/${encodeURIComponent(String(applId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    referUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling referUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling referUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/refer/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    rejectReferralUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling rejectReferralUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling rejectReferralUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/reject-referral/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    releaseDualSpclCaseUsingPOST(npnId, referrals, userId, observe = 'body', reportProgress = false) {
        if (npnId === null || npnId === undefined) {
            throw new Error('Required parameter npnId was null or undefined when calling releaseDualSpclCaseUsingPOST.');
        }
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling releaseDualSpclCaseUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling releaseDualSpclCaseUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/release-dual-spcl-case/${encodeURIComponent(String(userId))}/${encodeURIComponent(String(npnId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    releaseDualUsingPOST(npnId, referrals, userId, observe = 'body', reportProgress = false) {
        if (npnId === null || npnId === undefined) {
            throw new Error('Required parameter npnId was null or undefined when calling releaseDualUsingPOST.');
        }
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling releaseDualUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling releaseDualUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/release-dual/${encodeURIComponent(String(userId))}/${encodeURIComponent(String(npnId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    removeCaInterestUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling removeCaInterestUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling removeCaInterestUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/remove-ca-interest/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    reopenReferralUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling reopenReferralUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling reopenReferralUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/reopen-referral/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    transferUsingPOST(isXfer, npeId, transfers, userId, observe = 'body', reportProgress = false) {
        if (isXfer === null || isXfer === undefined) {
            throw new Error('Required parameter isXfer was null or undefined when calling transferUsingPOST.');
        }
        if (npeId === null || npeId === undefined) {
            throw new Error('Required parameter npeId was null or undefined when calling transferUsingPOST.');
        }
        if (transfers === null || transfers === undefined) {
            throw new Error('Required parameter transfers was null or undefined when calling transferUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling transferUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/pd-assignment/transfer/${encodeURIComponent(String(userId))}/${encodeURIComponent(String(npeId))}/${encodeURIComponent(String(isXfer))}`, transfers, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    transferUsingPOST1(npnId, referrals, userId, observe = 'body', reportProgress = false) {
        if (npnId === null || npnId === undefined) {
            throw new Error('Required parameter npnId was null or undefined when calling transferUsingPOST1.');
        }
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling transferUsingPOST1.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling transferUsingPOST1.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/transfer/${encodeURIComponent(String(userId))}/${encodeURIComponent(String(npnId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    unreferUsingPOST(referrals, userId, observe = 'body', reportProgress = false) {
        if (referrals === null || referrals === undefined) {
            throw new Error('Required parameter referrals was null or undefined when calling unreferUsingPOST.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling unreferUsingPOST.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.post(`${this.basePath}/api/v1/referral/unrefer/${encodeURIComponent(String(userId))}`, referrals, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    validateReferralActionUsingGET(action, applId, userNpnId, observe = 'body', reportProgress = false) {
        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling validateReferralActionUsingGET.');
        }
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling validateReferralActionUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (action !== undefined && action !== null) {
            queryParameters = queryParameters.set('action', action);
        }
        if (applId) {
            applId.forEach((element) => {
                queryParameters = queryParameters.append('applId', element);
            });
        }
        if (userNpnId !== undefined && userNpnId !== null) {
            queryParameters = queryParameters.set('userNpnId', userNpnId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/referral/validation`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    validateTransferGrantActionUsingGET(applId, userCayCodes, observe = 'body', reportProgress = false) {
        if (applId === null || applId === undefined) {
            throw new Error('Required parameter applId was null or undefined when calling validateTransferGrantActionUsingGET.');
        }
        if (userCayCodes === null || userCayCodes === undefined) {
            throw new Error('Required parameter userCayCodes was null or undefined when calling validateTransferGrantActionUsingGET.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (applId) {
            applId.forEach((element) => {
                queryParameters = queryParameters.append('applId', element);
            });
        }
        if (userCayCodes) {
            userCayCodes.forEach((element) => {
                queryParameters = queryParameters.append('userCayCodes', element);
            });
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/transferGrants/validation`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ReferralWorkflowControllerService.decorators = [
    { type: Injectable }
];
ReferralWorkflowControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class RoAssignmentControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getActiveROListUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ro-list/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDefaultROUsingGET(isDefaultRO, observe = 'body', reportProgress = false) {
        if (isDefaultRO === null || isDefaultRO === undefined) {
            throw new Error('Required parameter isDefaultRO was null or undefined when calling getDefaultROUsingGET.');
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ro-assignment-rules/${encodeURIComponent(String(isDefaultRO))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getRoAssignmentRulesListUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/ro-assignment-rules/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    inactivateAllRoAssignmentsUsingPATCH(roNpeId, observe = 'body', reportProgress = false) {
        if (roNpeId === null || roNpeId === undefined) {
            throw new Error('Required parameter roNpeId was null or undefined when calling inactivateAllRoAssignmentsUsingPATCH.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (roNpeId !== undefined && roNpeId !== null) {
            queryParameters = queryParameters.set('roNpeId', roNpeId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.patch(`${this.basePath}/api/v1/ro-assignment-rules/`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveOrUpdateDefaultRoUsingPUT(defaultRoNpeId, observe = 'body', reportProgress = false) {
        if (defaultRoNpeId === null || defaultRoNpeId === undefined) {
            throw new Error('Required parameter defaultRoNpeId was null or undefined when calling saveOrUpdateDefaultRoUsingPUT.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (defaultRoNpeId !== undefined && defaultRoNpeId !== null) {
            queryParameters = queryParameters.set('defaultRoNpeId', defaultRoNpeId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.put(`${this.basePath}/api/v1/ro-assignment-rules/`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    saveRoAssignmentUsingPUT(npeId, userId, mechList, rfaList, observe = 'body', reportProgress = false) {
        if (npeId === null || npeId === undefined) {
            throw new Error('Required parameter npeId was null or undefined when calling saveRoAssignmentUsingPUT.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling saveRoAssignmentUsingPUT.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (mechList) {
            mechList.forEach((element) => {
                queryParameters = queryParameters.append('mechList[]', element);
            });
        }
        if (rfaList) {
            rfaList.forEach((element) => {
                queryParameters = queryParameters.append('rfaList[]', element);
            });
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', userId);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.put(`${this.basePath}/api/v1/ro-assignments/${encodeURIComponent(String(npeId))}`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
RoAssignmentControllerService.decorators = [
    { type: Injectable }
];
RoAssignmentControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class UserControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getUsersUsingGET(activeFlag, term, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activeFlag !== undefined && activeFlag !== null) {
            queryParameters = queryParameters.set('activeFlag', activeFlag);
        }
        if (term !== undefined && term !== null) {
            queryParameters = queryParameters.set('term', term);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/nci-people/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    userUsingDELETE(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.delete(`${this.basePath}/api/v1/user`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    userUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/user`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    userUsingHEAD(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.head(`${this.basePath}/api/v1/user`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    userUsingOPTIONS(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.options(`${this.basePath}/api/v1/user`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    userUsingPATCH(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.patch(`${this.basePath}/api/v1/user`, null, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    userUsingPOST(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.post(`${this.basePath}/api/v1/user`, null, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    userUsingPUT(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        return this.httpClient.put(`${this.basePath}/api/v1/user`, null, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
UserControllerService.decorators = [
    { type: Injectable }
];
UserControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
class WorkbenchControllerService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getWorkbenchReferralActivityAppletUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml',
            'text/html'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/workbench/referral-activity-applet`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getWorkbenchReferralAppletUsingGET(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json',
            'application/xml',
            'text/html'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.get(`${this.basePath}/api/v1/workbench/referral-applet`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
WorkbenchControllerService.decorators = [
    { type: Injectable }
];
WorkbenchControllerService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];

const APIS = [ActivitiesCodeControllerService, ApiQueueEntityService, AppNavigationTControllerService, AppNavigationTEntityService, AraControllerService, AraReasonsControllerService, BoardsControllerService, CancerActivityControllerService, CancerActivityRolesControllerService, CgRefCodControllerService, EmControllerService, ExportControllerService, GwbLinksControllerService, I2eUserActiveRolesControllerService, IcDataControllerService, JasperReportControllerService, LookupsControllerService, NciReferralGrantsControllerService, PaylineCertificationsTEntityService, PaylineControllerService, PaylineStatusesTEntityService, PaylistControllerService, PaylistGrantsControllerService, PaylistUtilControllerService, PdControllerService, PropertiesControllerService, ReferralMessagesControllerService, ReferralMessagesTEntityService, ReferralSearchCriteriaControllerService, ReferralWorkflowControllerService, RoAssignmentControllerService, UserControllerService, WorkbenchControllerService];

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

var ModelAndView;
(function (ModelAndView) {
    ModelAndView.StatusEnum = {
        ACCEPTED: 'ACCEPTED',
        ALREADYREPORTED: 'ALREADY_REPORTED',
        BADGATEWAY: 'BAD_GATEWAY',
        BADREQUEST: 'BAD_REQUEST',
        BANDWIDTHLIMITEXCEEDED: 'BANDWIDTH_LIMIT_EXCEEDED',
        CHECKPOINT: 'CHECKPOINT',
        CONFLICT: 'CONFLICT',
        CONTINUE: 'CONTINUE',
        CREATED: 'CREATED',
        DESTINATIONLOCKED: 'DESTINATION_LOCKED',
        EXPECTATIONFAILED: 'EXPECTATION_FAILED',
        FAILEDDEPENDENCY: 'FAILED_DEPENDENCY',
        FORBIDDEN: 'FORBIDDEN',
        FOUND: 'FOUND',
        GATEWAYTIMEOUT: 'GATEWAY_TIMEOUT',
        GONE: 'GONE',
        HTTPVERSIONNOTSUPPORTED: 'HTTP_VERSION_NOT_SUPPORTED',
        IMUSED: 'IM_USED',
        INSUFFICIENTSPACEONRESOURCE: 'INSUFFICIENT_SPACE_ON_RESOURCE',
        INSUFFICIENTSTORAGE: 'INSUFFICIENT_STORAGE',
        INTERNALSERVERERROR: 'INTERNAL_SERVER_ERROR',
        IAMATEAPOT: 'I_AM_A_TEAPOT',
        LENGTHREQUIRED: 'LENGTH_REQUIRED',
        LOCKED: 'LOCKED',
        LOOPDETECTED: 'LOOP_DETECTED',
        METHODFAILURE: 'METHOD_FAILURE',
        METHODNOTALLOWED: 'METHOD_NOT_ALLOWED',
        MOVEDPERMANENTLY: 'MOVED_PERMANENTLY',
        MOVEDTEMPORARILY: 'MOVED_TEMPORARILY',
        MULTIPLECHOICES: 'MULTIPLE_CHOICES',
        MULTISTATUS: 'MULTI_STATUS',
        NETWORKAUTHENTICATIONREQUIRED: 'NETWORK_AUTHENTICATION_REQUIRED',
        NONAUTHORITATIVEINFORMATION: 'NON_AUTHORITATIVE_INFORMATION',
        NOTACCEPTABLE: 'NOT_ACCEPTABLE',
        NOTEXTENDED: 'NOT_EXTENDED',
        NOTFOUND: 'NOT_FOUND',
        NOTIMPLEMENTED: 'NOT_IMPLEMENTED',
        NOTMODIFIED: 'NOT_MODIFIED',
        NOCONTENT: 'NO_CONTENT',
        OK: 'OK',
        PARTIALCONTENT: 'PARTIAL_CONTENT',
        PAYLOADTOOLARGE: 'PAYLOAD_TOO_LARGE',
        PAYMENTREQUIRED: 'PAYMENT_REQUIRED',
        PERMANENTREDIRECT: 'PERMANENT_REDIRECT',
        PRECONDITIONFAILED: 'PRECONDITION_FAILED',
        PRECONDITIONREQUIRED: 'PRECONDITION_REQUIRED',
        PROCESSING: 'PROCESSING',
        PROXYAUTHENTICATIONREQUIRED: 'PROXY_AUTHENTICATION_REQUIRED',
        REQUESTEDRANGENOTSATISFIABLE: 'REQUESTED_RANGE_NOT_SATISFIABLE',
        REQUESTENTITYTOOLARGE: 'REQUEST_ENTITY_TOO_LARGE',
        REQUESTHEADERFIELDSTOOLARGE: 'REQUEST_HEADER_FIELDS_TOO_LARGE',
        REQUESTTIMEOUT: 'REQUEST_TIMEOUT',
        REQUESTURITOOLONG: 'REQUEST_URI_TOO_LONG',
        RESETCONTENT: 'RESET_CONTENT',
        SEEOTHER: 'SEE_OTHER',
        SERVICEUNAVAILABLE: 'SERVICE_UNAVAILABLE',
        SWITCHINGPROTOCOLS: 'SWITCHING_PROTOCOLS',
        TEMPORARYREDIRECT: 'TEMPORARY_REDIRECT',
        TOOEARLY: 'TOO_EARLY',
        TOOMANYREQUESTS: 'TOO_MANY_REQUESTS',
        UNAUTHORIZED: 'UNAUTHORIZED',
        UNAVAILABLEFORLEGALREASONS: 'UNAVAILABLE_FOR_LEGAL_REASONS',
        UNPROCESSABLEENTITY: 'UNPROCESSABLE_ENTITY',
        UNSUPPORTEDMEDIATYPE: 'UNSUPPORTED_MEDIA_TYPE',
        UPGRADEREQUIRED: 'UPGRADE_REQUIRED',
        URITOOLONG: 'URI_TOO_LONG',
        USEPROXY: 'USE_PROXY',
        VARIANTALSONEGOTIATES: 'VARIANT_ALSO_NEGOTIATES'
    };
})(ModelAndView || (ModelAndView = {}));

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

var Payload;
(function (Payload) {
    Payload.StatusEnum = {
        ACCEPTED: 'ACCEPTED',
        ALREADYREPORTED: 'ALREADY_REPORTED',
        BADGATEWAY: 'BAD_GATEWAY',
        BADREQUEST: 'BAD_REQUEST',
        BANDWIDTHLIMITEXCEEDED: 'BANDWIDTH_LIMIT_EXCEEDED',
        CHECKPOINT: 'CHECKPOINT',
        CONFLICT: 'CONFLICT',
        CONTINUE: 'CONTINUE',
        CREATED: 'CREATED',
        DESTINATIONLOCKED: 'DESTINATION_LOCKED',
        EXPECTATIONFAILED: 'EXPECTATION_FAILED',
        FAILEDDEPENDENCY: 'FAILED_DEPENDENCY',
        FORBIDDEN: 'FORBIDDEN',
        FOUND: 'FOUND',
        GATEWAYTIMEOUT: 'GATEWAY_TIMEOUT',
        GONE: 'GONE',
        HTTPVERSIONNOTSUPPORTED: 'HTTP_VERSION_NOT_SUPPORTED',
        IMUSED: 'IM_USED',
        INSUFFICIENTSPACEONRESOURCE: 'INSUFFICIENT_SPACE_ON_RESOURCE',
        INSUFFICIENTSTORAGE: 'INSUFFICIENT_STORAGE',
        INTERNALSERVERERROR: 'INTERNAL_SERVER_ERROR',
        IAMATEAPOT: 'I_AM_A_TEAPOT',
        LENGTHREQUIRED: 'LENGTH_REQUIRED',
        LOCKED: 'LOCKED',
        LOOPDETECTED: 'LOOP_DETECTED',
        METHODFAILURE: 'METHOD_FAILURE',
        METHODNOTALLOWED: 'METHOD_NOT_ALLOWED',
        MOVEDPERMANENTLY: 'MOVED_PERMANENTLY',
        MOVEDTEMPORARILY: 'MOVED_TEMPORARILY',
        MULTIPLECHOICES: 'MULTIPLE_CHOICES',
        MULTISTATUS: 'MULTI_STATUS',
        NETWORKAUTHENTICATIONREQUIRED: 'NETWORK_AUTHENTICATION_REQUIRED',
        NONAUTHORITATIVEINFORMATION: 'NON_AUTHORITATIVE_INFORMATION',
        NOTACCEPTABLE: 'NOT_ACCEPTABLE',
        NOTEXTENDED: 'NOT_EXTENDED',
        NOTFOUND: 'NOT_FOUND',
        NOTIMPLEMENTED: 'NOT_IMPLEMENTED',
        NOTMODIFIED: 'NOT_MODIFIED',
        NOCONTENT: 'NO_CONTENT',
        OK: 'OK',
        PARTIALCONTENT: 'PARTIAL_CONTENT',
        PAYLOADTOOLARGE: 'PAYLOAD_TOO_LARGE',
        PAYMENTREQUIRED: 'PAYMENT_REQUIRED',
        PERMANENTREDIRECT: 'PERMANENT_REDIRECT',
        PRECONDITIONFAILED: 'PRECONDITION_FAILED',
        PRECONDITIONREQUIRED: 'PRECONDITION_REQUIRED',
        PROCESSING: 'PROCESSING',
        PROXYAUTHENTICATIONREQUIRED: 'PROXY_AUTHENTICATION_REQUIRED',
        REQUESTEDRANGENOTSATISFIABLE: 'REQUESTED_RANGE_NOT_SATISFIABLE',
        REQUESTENTITYTOOLARGE: 'REQUEST_ENTITY_TOO_LARGE',
        REQUESTHEADERFIELDSTOOLARGE: 'REQUEST_HEADER_FIELDS_TOO_LARGE',
        REQUESTTIMEOUT: 'REQUEST_TIMEOUT',
        REQUESTURITOOLONG: 'REQUEST_URI_TOO_LONG',
        RESETCONTENT: 'RESET_CONTENT',
        SEEOTHER: 'SEE_OTHER',
        SERVICEUNAVAILABLE: 'SERVICE_UNAVAILABLE',
        SWITCHINGPROTOCOLS: 'SWITCHING_PROTOCOLS',
        TEMPORARYREDIRECT: 'TEMPORARY_REDIRECT',
        TOOEARLY: 'TOO_EARLY',
        TOOMANYREQUESTS: 'TOO_MANY_REQUESTS',
        UNAUTHORIZED: 'UNAUTHORIZED',
        UNAVAILABLEFORLEGALREASONS: 'UNAVAILABLE_FOR_LEGAL_REASONS',
        UNPROCESSABLEENTITY: 'UNPROCESSABLE_ENTITY',
        UNSUPPORTEDMEDIATYPE: 'UNSUPPORTED_MEDIA_TYPE',
        UPGRADEREQUIRED: 'UPGRADE_REQUIRED',
        URITOOLONG: 'URI_TOO_LONG',
        USEPROXY: 'USE_PROXY',
        VARIANTALSONEGOTIATES: 'VARIANT_ALSO_NEGOTIATES'
    };
})(Payload || (Payload = {}));

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var ResponseEntity;
(function (ResponseEntity) {
    ResponseEntity.StatusCodeEnum = {
        ACCEPTED: 'ACCEPTED',
        ALREADYREPORTED: 'ALREADY_REPORTED',
        BADGATEWAY: 'BAD_GATEWAY',
        BADREQUEST: 'BAD_REQUEST',
        BANDWIDTHLIMITEXCEEDED: 'BANDWIDTH_LIMIT_EXCEEDED',
        CHECKPOINT: 'CHECKPOINT',
        CONFLICT: 'CONFLICT',
        CONTINUE: 'CONTINUE',
        CREATED: 'CREATED',
        DESTINATIONLOCKED: 'DESTINATION_LOCKED',
        EXPECTATIONFAILED: 'EXPECTATION_FAILED',
        FAILEDDEPENDENCY: 'FAILED_DEPENDENCY',
        FORBIDDEN: 'FORBIDDEN',
        FOUND: 'FOUND',
        GATEWAYTIMEOUT: 'GATEWAY_TIMEOUT',
        GONE: 'GONE',
        HTTPVERSIONNOTSUPPORTED: 'HTTP_VERSION_NOT_SUPPORTED',
        IMUSED: 'IM_USED',
        INSUFFICIENTSPACEONRESOURCE: 'INSUFFICIENT_SPACE_ON_RESOURCE',
        INSUFFICIENTSTORAGE: 'INSUFFICIENT_STORAGE',
        INTERNALSERVERERROR: 'INTERNAL_SERVER_ERROR',
        IAMATEAPOT: 'I_AM_A_TEAPOT',
        LENGTHREQUIRED: 'LENGTH_REQUIRED',
        LOCKED: 'LOCKED',
        LOOPDETECTED: 'LOOP_DETECTED',
        METHODFAILURE: 'METHOD_FAILURE',
        METHODNOTALLOWED: 'METHOD_NOT_ALLOWED',
        MOVEDPERMANENTLY: 'MOVED_PERMANENTLY',
        MOVEDTEMPORARILY: 'MOVED_TEMPORARILY',
        MULTIPLECHOICES: 'MULTIPLE_CHOICES',
        MULTISTATUS: 'MULTI_STATUS',
        NETWORKAUTHENTICATIONREQUIRED: 'NETWORK_AUTHENTICATION_REQUIRED',
        NONAUTHORITATIVEINFORMATION: 'NON_AUTHORITATIVE_INFORMATION',
        NOTACCEPTABLE: 'NOT_ACCEPTABLE',
        NOTEXTENDED: 'NOT_EXTENDED',
        NOTFOUND: 'NOT_FOUND',
        NOTIMPLEMENTED: 'NOT_IMPLEMENTED',
        NOTMODIFIED: 'NOT_MODIFIED',
        NOCONTENT: 'NO_CONTENT',
        OK: 'OK',
        PARTIALCONTENT: 'PARTIAL_CONTENT',
        PAYLOADTOOLARGE: 'PAYLOAD_TOO_LARGE',
        PAYMENTREQUIRED: 'PAYMENT_REQUIRED',
        PERMANENTREDIRECT: 'PERMANENT_REDIRECT',
        PRECONDITIONFAILED: 'PRECONDITION_FAILED',
        PRECONDITIONREQUIRED: 'PRECONDITION_REQUIRED',
        PROCESSING: 'PROCESSING',
        PROXYAUTHENTICATIONREQUIRED: 'PROXY_AUTHENTICATION_REQUIRED',
        REQUESTEDRANGENOTSATISFIABLE: 'REQUESTED_RANGE_NOT_SATISFIABLE',
        REQUESTENTITYTOOLARGE: 'REQUEST_ENTITY_TOO_LARGE',
        REQUESTHEADERFIELDSTOOLARGE: 'REQUEST_HEADER_FIELDS_TOO_LARGE',
        REQUESTTIMEOUT: 'REQUEST_TIMEOUT',
        REQUESTURITOOLONG: 'REQUEST_URI_TOO_LONG',
        RESETCONTENT: 'RESET_CONTENT',
        SEEOTHER: 'SEE_OTHER',
        SERVICEUNAVAILABLE: 'SERVICE_UNAVAILABLE',
        SWITCHINGPROTOCOLS: 'SWITCHING_PROTOCOLS',
        TEMPORARYREDIRECT: 'TEMPORARY_REDIRECT',
        TOOEARLY: 'TOO_EARLY',
        TOOMANYREQUESTS: 'TOO_MANY_REQUESTS',
        UNAUTHORIZED: 'UNAUTHORIZED',
        UNAVAILABLEFORLEGALREASONS: 'UNAVAILABLE_FOR_LEGAL_REASONS',
        UNPROCESSABLEENTITY: 'UNPROCESSABLE_ENTITY',
        UNSUPPORTEDMEDIATYPE: 'UNSUPPORTED_MEDIA_TYPE',
        UPGRADEREQUIRED: 'UPGRADE_REQUIRED',
        URITOOLONG: 'URI_TOO_LONG',
        USEPROXY: 'USE_PROXY',
        VARIANTALSONEGOTIATES: 'VARIANT_ALSO_NEGOTIATES'
    };
})(ResponseEntity || (ResponseEntity = {}));

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var TemplateVariable;
(function (TemplateVariable) {
    TemplateVariable.TypeEnum = {
        COMPOSITEPARAM: 'COMPOSITE_PARAM',
        FRAGMENT: 'FRAGMENT',
        PATHVARIABLE: 'PATH_VARIABLE',
        REQUESTPARAM: 'REQUEST_PARAM',
        REQUESTPARAMCONTINUED: 'REQUEST_PARAM_CONTINUED',
        SEGMENT: 'SEGMENT'
    };
})(TemplateVariable || (TemplateVariable = {}));

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

class ApiModule {
    constructor(parentModule, http) {
        if (parentModule) {
            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
        }
        if (!http) {
            throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
                'See also https://github.com/angular/angular/issues/20575');
        }
    }
    static forRoot(configurationFactory) {
        return {
            ngModule: ApiModule,
            providers: [{ provide: Configuration, useFactory: configurationFactory }]
        };
    }
}
ApiModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [],
                exports: [],
                providers: [
                    ActivitiesCodeControllerService,
                    ApiQueueEntityService,
                    AppNavigationTControllerService,
                    AppNavigationTEntityService,
                    AraControllerService,
                    AraReasonsControllerService,
                    BoardsControllerService,
                    CancerActivityControllerService,
                    CancerActivityRolesControllerService,
                    CgRefCodControllerService,
                    EmControllerService,
                    ExportControllerService,
                    GwbLinksControllerService,
                    I2eUserActiveRolesControllerService,
                    IcDataControllerService,
                    JasperReportControllerService,
                    LookupsControllerService,
                    NciReferralGrantsControllerService,
                    PaylineCertificationsTEntityService,
                    PaylineControllerService,
                    PaylineStatusesTEntityService,
                    PaylistControllerService,
                    PaylistGrantsControllerService,
                    PaylistUtilControllerService,
                    PdControllerService,
                    PropertiesControllerService,
                    ReferralMessagesControllerService,
                    ReferralMessagesTEntityService,
                    ReferralSearchCriteriaControllerService,
                    ReferralWorkflowControllerService,
                    RoAssignmentControllerService,
                    UserControllerService,
                    WorkbenchControllerService
                ]
            },] }
];
ApiModule.ctorParameters = () => [
    { type: ApiModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: HttpClient, decorators: [{ type: Optional }] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { APIS, ActivitiesCodeControllerService, ApiModule, ApiQueueEntityService, AppNavigationTControllerService, AppNavigationTEntityService, AraControllerService, AraReasonsControllerService, BASE_PATH, BoardsControllerService, COLLECTION_FORMATS, CancerActivityControllerService, CancerActivityRolesControllerService, CgRefCodControllerService, Configuration, EmControllerService, ExportControllerService, GwbLinksControllerService, I2eUserActiveRolesControllerService, IcDataControllerService, JasperReportControllerService, LookupsControllerService, ModelAndView, NciReferralGrantsControllerService, PaylineCertificationsTEntityService, PaylineControllerService, PaylineStatusesTEntityService, PaylistControllerService, PaylistGrantsControllerService, PaylistUtilControllerService, Payload, PdControllerService, PropertiesControllerService, ReferralMessagesControllerService, ReferralMessagesTEntityService, ReferralSearchCriteriaControllerService, ReferralWorkflowControllerService, ResponseEntity, RoAssignmentControllerService, TemplateVariable, UserControllerService, WorkbenchControllerService };
//# sourceMappingURL=i2ecws-lib.js.map
